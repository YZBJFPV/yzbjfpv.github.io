<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>PPT|FlyzOffice</title>
  <!-- 引入外部资源（确保PPT动画、触屏绘画、解析生成功能正常） -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <!-- 核心PPT处理库（支持动画、解析、生成） -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxjs@1.4.1/dist/pptx.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pptxjs@1.4.1/dist/pptx.css">
  <!-- Fabric画布（优化触屏绘画） -->
  <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>

  <!-- 自定义配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#2563eb',
            neutral: '#f8fafc'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>

  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .transition-base {
        transition: all 0.2s ease;
      }
      .shadow-light {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      /* 触屏优化：去除点击延迟、优化触摸反馈 */
      .touch-optimized {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
    }
  </style>

  <style>
    /* 基础样式优化 */
    body {
      font-feature-settings: "cv02", "cv03", "cv04", "cv11";
      overflow-x: hidden;
    }
    /* 画布样式（优化Windows11触屏绘画） */
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: crosshair;
      touch-action: none; /* 禁用默认触摸行为 */
      z-index: 10; /* 确保画笔在PPT上方 */
      -webkit-user-select: none;
      user-select: none;
    }
    /* 全屏样式优化 */
    :-webkit-full-screen {
      background-color: white;
    }
    :fullscreen {
      background-color: white;
    }
    /* 加载动画 */
    .loader {
      border-top-color: #2563eb;
      animation: spinner 0.6s linear infinite;
    }
    @keyframes spinner {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* 缩略图样式优化 */
    .thumbnail-item {
      transition: all 0.15s ease;
    }
    .thumbnail-item.active {
      ring: 2px ring-primary;
    }
    .thumbnail-item:hover:not(.active) {
      ring: 2px ring-gray-300;
    }
    /* PPT内容容器（确保动画正常渲染） */
    #slideContent {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      overflow: hidden;
    }
    /* 触屏按钮优化（增大点击区域） */
    .touch-btn {
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* 画笔颜色选择器优化（触屏易点击） */
    [data-color] {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      transition: all 0.1s ease;
    }
    [data-color]:active {
      transform: scale(0.9);
    }
    /* 滑动条样式优化（Windows11适配） */
    input[type="range"] {
      -webkit-appearance: none;
      height: 4px;
      border-radius: 2px;
      background: #e2e8f0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #2563eb;
      cursor: pointer;
      transition: all 0.1s ease;
    }
    input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(1.2);
    }
  </style>
</head>
<body class="font-sans bg-neutral text-gray-800 min-h-screen flex flex-col">
  <!-- 顶部导航栏（含正方形Logo） -->
  <header class="bg-white shadow-sm sticky top-0 z-50 transition-all duration-300">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <!-- 左上角Logo+标题 -->
      <div class="flex items-center space-x-3">
        <div class="w-10 h-10 rounded-md overflow-hidden border border-gray-100 shadow-sm">
          <img src="https://www.img520.com/UIGuUV.jpeg" alt="PPT工具Logo" class="w-full h-full object-cover">
        </div>
        <h1 class="text-lg font-semibold text-gray-800">FlyzOffice</h1>
      </div>
      
      <!-- 右侧功能按钮（移除编辑相关，保留核心功能） -->
      <div class="flex items-center space-x-3">
        <button id="uploadBtn" class="flex items-center space-x-1 bg-primary hover:bg-primary/90 text-white px-3 py-1.5 rounded-md text-sm transition-base touch-optimized">
          <i class="fa fa-upload text-xs"></i>
          <span>上传PPT</span>
        </button>
        <input type="file" id="fileInput" accept=".pptx" class="hidden">
        
        <button id="saveFileBtn" class="flex items-center space-x-1 bg-green-500 hover:bg-green-600 text-white px-3 py-1.5 rounded-md text-sm transition-base hidden touch-optimized" disabled>
          <i class="fa fa-save text-xs"></i>
          <span>保存批注</span>
        </button>
      </div>
    </div>
  </header>

  <!-- 主内容区 -->
  <main class="flex-1 container mx-auto px-4 py-6 flex flex-col lg:flex-row gap-6">
    <!-- 左侧上传区域（初始状态） -->
    <div id="uploadArea" class="lg:w-1/4 bg-white rounded-xl shadow-light p-6 flex flex-col items-center justify-center text-center">
      <div class="w-20 h-20 bg-primary/5 rounded-full flex items-center justify-center mb-4">
        <i class="fa fa-file-powerpoint-o text-primary text-3xl"></i>
      </div>
      <h2 class="text-lg font-medium mb-2">上传PPT文件</h2>
      <p class="text-gray-500 text-sm mb-6">支持Win11触屏绘画 | 保留批注 | 原动画不变</p>
      <label for="fileInput" class="cursor-pointer bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-base flex items-center space-x-2 touch-optimized">
        <i class="fa fa-upload"></i>
        <span>选择文件</span>
      </label>
      <p class="text-xs text-gray-400 mt-3">最大支持666页以内文件</p>
    </div>

    <!-- 左侧工具栏（移除编辑工具，保留导航和简洁画笔工具） -->
    <div id="toolSidebar" class="lg:w-1/4 hidden flex-col gap-4">
      <!-- 幻灯片导航 -->
      <div class="bg-white rounded-xl shadow-light p-4">
        <h3 class="font-medium text-gray-700 text-sm mb-3 flex items-center">
          <i class="fa fa-th-list text-primary mr-1.5 text-xs"></i>
          幻灯片导航
        </h3>
        <div id="thumbnailContainer" class="grid grid-cols-2 gap-2 max-h-[300px] overflow-y-auto p-1">
          <!-- 缩略图动态生成 -->
        </div>
      </div>

      <!-- 简洁批注工具（保留核心画笔功能） -->
      <div class="bg-white rounded-xl shadow-light p-4">
        <h3 class="font-medium text-gray-700 text-sm mb-3 flex items-center">
          <i class="fa fa-paint-brush text-primary mr-1.5 text-xs"></i>
          批注工具
        </h3>
        <div class="space-y-3">
          <!-- 颜色选择（增大点击区域，适配触屏） -->
          <div>
            <label class="block text-xs text-gray-500 mb-1.5">画笔颜色</label>
            <div class="flex space-x-2">
              <button class="w-7 h-7 rounded-full bg-red-500 border-2 border-primary scale-110 transition-base" data-color="#ef4444"></button>
              <button class="w-7 h-7 rounded-full bg-blue-500 border-2 border-transparent hover:scale-110 transition-base" data-color="#3b82f6"></button>
              <button class="w-7 h-7 rounded-full bg-green-500 border-2 border-transparent hover:scale-110 transition-base" data-color="#22c55e"></button>
              <button class="w-7 h-7 rounded-full bg-yellow-500 border-2 border-transparent hover:scale-110 transition-base" data-color="#eab308"></button>
              <button class="w-7 h-7 rounded-full bg-black border-2 border-transparent hover:scale-110 transition-base" data-color="#000000"></button>
            </div>
          </div>
          
          <!-- 粗细调节（适配触屏滑动） -->
          <div>
            <label class="block text-xs text-gray-500 mb-1.5">画笔粗细</label>
            <input type="range" id="brushSize" min="2" max="10" value="3" class="w-full accent-primary">
            <div class="flex justify-between text-xs text-gray-400 mt-1">
              <span>细</span>
              <span>粗</span>
            </div>
          </div>
          
          <!-- 核心操作按钮（简洁布局，适配触屏） -->
          <div class="flex space-x-2">
            <button id="clearAnnotations" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 px-2 py-2 rounded-md text-sm transition-base touch-optimized">
              <i class="fa fa-eraser text-xs mr-1"></i> 清除当前页
            </button>
            <button id="toggleDrawing" class="flex-1 bg-primary text-white px-2 py-2 rounded-md text-sm transition-base touch-optimized">
              <i class="fa fa-pencil text-xs mr-1"></i> 手写模式
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- 右侧PPT预览与演示区（优化动画渲染和触屏体验） -->
    <div id="pptEditor" class="lg:w-3/4 bg-white rounded-xl shadow-light p-4 flex flex-col items-center justify-center hidden">
      <div class="relative w-full max-w-3xl aspect-[16/9] bg-white rounded-lg overflow-hidden border border-gray-200" id="slideContainer">
        <!-- 幻灯片内容容器（确保动画正常播放） -->
        <div id="slideContent" class="w-full h-full">
          <!-- 动态生成幻灯片内容（含原动画） -->
        </div>
        <!-- 手写批注画布（优化Windows11触屏） -->
        <canvas id="drawingCanvas" class="w-full h-full"></canvas>
      </div>
      
      <!-- 控制栏（增大按钮，适配触屏） -->
      <div class="mt-4 flex items-center justify-between w-full max-w-3xl">
        <div class="flex items-center space-x-4">
          <button id="prevSlide" class="p-3 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-700 transition-base disabled:opacity-50 disabled:cursor-not-allowed touch-btn" disabled>
            <i class="fa fa-chevron-left"></i>
          </button>
          <span id="slideCounter" class="text-gray-500 text-sm min-w-[60px] text-center">1 / 0</span>
          <button id="nextSlide" class="p-3 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-700 transition-base disabled:opacity-50 disabled:cursor-not-allowed touch-btn" disabled>
            <i class="fa fa-chevron-right"></i>
          </button>
        </div>
        
        <div class="flex items-center space-x-3">
          <button id="playAnimationBtn" class="px-4 py-2 rounded-md bg-primary/10 hover:bg-primary/20 text-primary text-sm transition-base touch-optimized">
            <i class="fa fa-play text-xs mr-1"></i> 播放动画
          </button>
          <button id="fullscreenBtn" class="px-4 py-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700 text-sm transition-base touch-optimized">
            <i class="fa fa-expand text-xs mr-1"></i> 全屏
          </button>
        </div>
      </div>
    </div>

    <!-- 加载状态 -->
    <div id="loadingArea" class="lg:w-3/4 hidden flex-col items-center justify-center bg-white rounded-xl shadow-light p-6">
      <div class="loader w-10 h-10 border-3 border-gray-100 rounded-full mb-3"></div>
      <h3 class="text-base font-medium text-gray-700">正在解析文件...</h3>
      <p class="text-gray-500 text-sm mt-1" id="loadingProgress">处理中，请稍候</p>
    </div>
  </main>
      <!-- 页脚 -->
  <footer class="bg-white border-t border-gray-100 py-3 mt-6">
    <div class="container mx-auto px-4 text-center text-gray-500 text-xs">
      <p>版本V1.0.1_20251113 | Flyz远征飞官方出品 | 适配Windows11触屏</p>
    </div>
  </footer>

  <script>
    // 全局核心变量（精简无用编辑相关变量）
    let pptData = {
      slides: [], // 存储所有幻灯片数据（含原动画信息）
      currentSlideIndex: 0, // 当前激活的幻灯片索引
      isDrawingMode: false, // 是否处于手写批注模式
      brushColor: '#ef4444', // 画笔默认颜色
      brushSize: 3, // 画笔默认粗细
      fabricCanvas: null, // Fabric主画布对象（触屏优化）
      slideAnnotations: [], // 存储每个幻灯片的批注（仅保留画笔轨迹）
      isFileLoaded: false, // 是否已加载PPT文件
      pptRenderer: null // PPT渲染器实例（用于保留原动画）
    };

    // DOM元素缓存（移除编辑功能相关元素）
    const elements = {
      fileInput: document.getElementById('fileInput'),
      uploadBtn: document.getElementById('uploadBtn'),
      uploadArea: document.getElementById('uploadArea'),
      toolSidebar: document.getElementById('toolSidebar'),
      pptEditor: document.getElementById('pptEditor'),
      loadingArea: document.getElementById('loadingArea'),
      thumbnailContainer: document.getElementById('thumbnailContainer'),
      slideContent: document.getElementById('slideContent'),
      slideCounter: document.getElementById('slideCounter'),
      prevSlide: document.getElementById('prevSlide'),
      nextSlide: document.getElementById('nextSlide'),
      toggleDrawing: document.getElementById('toggleDrawing'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      clearAnnotations: document.getElementById('clearAnnotations'),
      saveFileBtn: document.getElementById('saveFileBtn'),
      brushSize: document.getElementById('brushSize'),
      colorButtons: document.querySelectorAll('[data-color]'),
      loadingProgress: document.getElementById('loadingProgress'),
      header: document.querySelector('header'),
      playAnimationBtn: document.getElementById('playAnimationBtn') // 新增动画播放按钮
    };

    // 初始化函数（程序入口）
    function init() {
      // 绑定所有事件监听（移除编辑相关事件）
      bindAllEvents();
      // 初始化Fabric画布（优化Windows11触屏）
      initFabricCanvas();
      // 默认选中第一个画笔颜色
      elements.colorButtons[0].classList.add('border-primary', 'scale-110');
      // 监听窗口滚动，优化导航栏样式
      window.addEventListener('scroll', () => {
        if (window.scrollY > 10) {
          elements.header.classList.add('py-2', 'shadow');
          elements.header.classList.remove('py-3', 'shadow-sm');
        } else {
          elements.header.classList.add('py-3', 'shadow-sm');
          elements.header.classList.remove('py-2', 'shadow');
        }
      });
    }

    // 绑定所有事件处理函数（移除编辑相关事件）
    function bindAllEvents() {
      // 1. 文件上传相关事件
      elements.uploadBtn.addEventListener('click', () => elements.fileInput.click());
      elements.fileInput.addEventListener('change', handlePPTUpload);

      // 2. 幻灯片导航控制事件
      elements.prevSlide.addEventListener('click', showPrevSlide);
      elements.nextSlide.addEventListener('click', showNextSlide);
      elements.fullscreenBtn.addEventListener('click', toggleFullscreen);
      document.addEventListener('fullscreenchange', updateFullscreenBtn);

      // 3. 批注工具事件（仅保留画笔相关）
      elements.toggleDrawing.addEventListener('click', toggleDrawingMode);
      elements.clearAnnotations.addEventListener('click', clearCurrentSlideAnnotations);
      elements.brushSize.addEventListener('input', updateBrushSize);
      elements.colorButtons.forEach(btn => {
        btn.addEventListener('click', (e) => updateBrushColor(e));
      });

      // 4. 文件保存事件（仅保存批注）
      elements.saveFileBtn.addEventListener('click', saveAnnotations);

      // 5. 动画播放事件
      elements.playAnimationBtn.addEventListener('click', playCurrentSlideAnimation);
    }

    // 初始化Fabric画布（重点优化Windows11触屏体验）
    function initFabricCanvas() {
      const canvasDom = document.getElementById('drawingCanvas');
      // 创建Fabric画布实例（开启触屏优化）
      pptData.fabricCanvas = new fabric.Canvas('drawingCanvas', {
        isDrawingMode: false, // 初始关闭手写模式
        preserveObjectStacking: true, // 保持批注堆叠顺序
        selection: false, // 关闭对象选择（仅保留画笔功能）
        width: canvasDom.offsetWidth,
        height: canvasDom.offsetHeight,
        // 触屏优化配置
        targetFindTolerance: 10, // 增大触摸检测容错
        perPixelTargetFind: true,
        imageSmoothingEnabled: true // 优化画笔线条平滑度
      });

      // 初始化画笔样式（适配触屏绘画手感）
      const brush = new fabric.PencilBrush(pptData.fabricCanvas);
      brush.color = pptData.brushColor;
      brush.width = pptData.brushSize;
      brush.strokeLineCap = 'round'; // 画笔端点圆润
      brush.strokeLineJoin = 'round'; // 画笔转角圆润
      brush.decimate = 1; // 减少线条顶点，优化性能
      pptData.fabricCanvas.freeDrawingBrush = brush;

      // 监听容器大小变化，自适应调整画布尺寸
      new ResizeObserver(entries => {
        const { width, height } = entries[0].contentRect;
        canvasDom.width = width;
        canvasDom.height = height;
        pptData.fabricCanvas.setWidth(width);
        pptData.fabricCanvas.setHeight(height);
        // 重新渲染当前幻灯片批注
        if (pptData.isFileLoaded) {
          renderCurrentSlideAnnotations();
        }
      }).observe(document.getElementById('slideContainer'));

      // 优化触屏绘画体验：添加触摸开始/结束事件
      canvasDom.addEventListener('touchstart', (e) => {
        if (pptData.isDrawingMode) {
          // 禁用触摸事件默认行为，避免滚动冲突
          e.preventDefault();
          // 模拟鼠标按下事件，确保画笔响应
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY,
            bubbles: true,
            cancelable: true
          });
          canvasDom.dispatchEvent(mouseEvent);
        }
      });

      canvasDom.addEventListener('touchend', (e) => {
        if (pptData.isDrawingMode) {
          e.preventDefault();
          const touch = e.changedTouches[0];
          const mouseEvent = new MouseEvent('mouseup', {
            clientX: touch.clientX,
            clientY: touch.clientY,
            bubbles: true,
            cancelable: true
          });
          canvasDom.dispatchEvent(mouseEvent);
        }
      });

      canvasDom.addEventListener('touchmove', (e) => {
        if (pptData.isDrawingMode) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY,
            bubbles: true,
            cancelable: true
          });
          canvasDom.dispatchEvent(mouseEvent);
        }
      });
    }

    // 处理PPT文件上传（使用pptxjs真实解析，保留原动画）
    function handlePPTUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      // 验证文件类型和大小
      if (!file.name.endsWith('.pptx')) {
        showNotification('请上传.pptx格式的PPT文件', 'error');
        return;
      }

      // 切换UI状态到加载中
      elements.uploadArea.classList.add('hidden');
      elements.pptEditor.classList.add('hidden');
      elements.toolSidebar.classList.add('hidden');
      elements.loadingArea.classList.remove('hidden');

      // 使用pptxjs解析PPT（保留原动画和格式）
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = new Uint8Array(e.target.result);
          // 初始化PPT渲染器
          pptData.pptRenderer = new PPTX.Presentation();
          pptData.pptRenderer.load(data).then(() => {
            parsePPTContentWithAnimations();
          }).catch(error => {
            throw error;
          });
        } catch (error) {
          console.error('PPT解析失败:', error);
          elements.loadingProgress.textContent = '解析失败，请尝试其他文件';
          setTimeout(() => {
            elements.loadingArea.classList.add('hidden');
            elements.uploadArea.classList.remove('hidden');
          }, 2000);
        }
      };
      reader.readAsArrayBuffer(file);
    }

    // 解析PPT内容（保留原动画，pptxjs核心功能）
    function parsePPTContentWithAnimations() {
      pptData.slides = [];
      pptData.slideAnnotations = [];
      const totalSlides = pptData.pptRenderer.getSlideCount();
      const maxSlides = Math.min(totalSlides, 666); // 限制最大666页

      // 批量解析幻灯片（保留动画信息）
      const parsePromises = [];
      for (let i = 0; i < maxSlides; i++) {
        parsePromises.push(
          new Promise(resolve => {
            elements.loadingProgress.textContent = `解析第 ${i+1}/${maxSlides} 页（保留动画）`;
            // 获取幻灯片原始数据（含动画）
            pptData.pptRenderer.getSlide(i).then(slide => {
              // 生成幻灯片HTML（含动画脚本）
              const slideHtml = slide.getHTML();
              // 生成缩略图（简化预览）
              const thumbnailHtml = `
                <div class="aspect-[16/9] bg-white border border-gray-200 rounded-md flex items-center justify-center p-2">
                  <span class="text-xs text-gray-500">第 ${i+1} 页</span>
                </div>
              `;

              // 存储幻灯片数据（含动画HTML）
              pptData.slides.push({
                id: `slide-${i}`,
                html: slideHtml, // 含原动画的HTML
                thumbnail: thumbnailHtml,
                hasAnimation: slide.hasAnimations() // 标记是否有动画
              });

              // 初始化当前幻灯片的批注容器
              pptData.slideAnnotations[i] = [];
              setTimeout(resolve, 100); // 控制解析速度，避免卡顿
            });
          })
        );
      }

      // 所有幻灯片解析完成
      Promise.all(parsePromises).then(() => {
        initPPTEditor();
      });
    }

    // 初始化PPT编辑环境（解析完成后调用）
    function initPPTEditor() {
      // 切换UI状态
      elements.loadingArea.classList.add('hidden');
      elements.toolSidebar.classList.remove('hidden');
      elements.pptEditor.classList.remove('hidden');

      // 生成幻灯片缩略图导航
      renderSlideThumbnails();

      // 显示第一页幻灯片（含动画）
      showSlide(0);

      // 更新计数器和控制按钮状态
      updateSlideCounter();
      updateNavButtonsStatus();
      updateAnimationButtonStatus();

      // 启用保存按钮
      pptData.isFileLoaded = true;
      elements.saveFileBtn.disabled = false;
      elements.saveFileBtn.classList.remove('hidden');

      showNotification('PPT加载成功，原动画已保留');
    }

    // 渲染幻灯片缩略图导航
    function renderSlideThumbnails() {
      elements.thumbnailContainer.innerHTML = '';
      pptData.slides.forEach((slide, index) => {
        const thumbnailEl = document.createElement('div');
        thumbnailEl.className = `thumbnail-item cursor-pointer rounded-md overflow-hidden transition-base ${
          index === 0 ? 'ring-2 ring-primary' : 'hover:ring-2 hover:ring-gray-300'
        }`;
        thumbnailEl.innerHTML = slide.thumbnail;
        thumbnailEl.addEventListener('click', () => showSlide(index));
        elements.thumbnailContainer.appendChild(thumbnailEl);
      });
    }

    // 显示指定索引的幻灯片（含原动画和批注）
    function showSlide(index) {
      if (index < 0 || index >= pptData.slides.length) return;

      // 保存当前幻灯片的批注
      if (pptData.currentSlideIndex >= 0 && pptData.currentSlideIndex < pptData.slideAnnotations.length) {
        pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
      }

      // 更新当前幻灯片索引
      pptData.currentSlideIndex = index;

      // 渲染幻灯片HTML（含原动画）
      elements.slideContent.innerHTML = pptData.slides[index].html;

      // 重新初始化当前幻灯片的动画脚本
      initSlideAnimation(index);

      // 渲染当前幻灯片的批注
      renderCurrentSlideAnnotations();

      // 更新UI状态
      updateThumbnailActiveStatus();
      updateSlideCounter();
      updateNavButtonsStatus();
      updateAnimationButtonStatus();
    }

    // 初始化幻灯片动画（确保原动画可播放）
    function initSlideAnimation(index) {
      const slide = pptData.slides[index];
      if (!slide.hasAnimation) return;

      // 执行幻灯片中的动画脚本（pptxjs生成的原生动画）
      const slideScripts = elements.slideContent.querySelectorAll('script');
      slideScripts.forEach(script => {
        try {
          // 重新执行动画脚本，确保动画可触发
          const newScript = document.createElement('script');
          newScript.textContent = script.textContent;
          elements.slideContent.appendChild(newScript);
          elements.slideContent.removeChild(newScript);
        } catch (error) {
          console.warn('动画初始化失败:', error);
        }
      });
    }

    // 播放当前幻灯片动画
    function playCurrentSlideAnimation() {
      const slide = pptData.slides[pptData.currentSlideIndex];
      if (!slide.hasAnimation) {
        showNotification('当前幻灯片无动画');
        return;
      }

      // 触发pptxjs生成的动画播放函数
      try {
        // pptxjs会在全局注册幻灯片动画函数，格式为slide{索引}_play()
        const playFunction = window[`slide${pptData.currentSlideIndex}_play`];
        if (typeof playFunction === 'function') {
          playFunction();
          showNotification('动画播放中...');
        } else {
          // 备选方案：触发所有动画元素的播放
          const animationElements = elements.slideContent.querySelectorAll('[data-animation]');
          animationElements.forEach(el => {
            el.style.animationPlayState = 'running';
          });
          showNotification('动画播放中...');
        }
      } catch (error) {
        console.error('动画播放失败:', error);
        showNotification('动画播放失败', 'error');
      }
    }

    // 渲染当前幻灯片的批注
    function renderCurrentSlideAnnotations() {
      // 清空画布
      pptData.fabricCanvas.clear();

      // 恢复当前幻灯片的批注
      const currentAnnotations = pptData.slideAnnotations[pptData.currentSlideIndex] || [];
      currentAnnotations.forEach(annotation => {
        pptData.fabricCanvas.add(annotation);
      });

      // 恢复手写模式状态
      pptData.fabricCanvas.isDrawingMode = pptData.isDrawingMode;
    }

    // 更新缩略图选中状态
    function updateThumbnailActiveStatus() {
      const thumbnails = elements.thumbnailContainer.querySelectorAll('.thumbnail-item');
      thumbnails.forEach((thumb, index) => {
        if (index === pptData.currentSlideIndex) {
          thumb.classList.add('ring-2', 'ring-primary');
          thumb.classList.remove('hover:ring-2', 'hover:ring-gray-300');
        } else {
          thumb.classList.remove('ring-2', 'ring-primary');
          thumb.classList.add('hover:ring-2', 'hover:ring-gray-300');
        }
      });
    }

    // 更新幻灯片计数器
    function updateSlideCounter() {
      elements.slideCounter.textContent = `${pptData.currentSlideIndex + 1} / ${pptData.slides.length}`;
    }

    // 更新导航按钮状态（禁用/启用）
    function updateNavButtonsStatus() {
      elements.prevSlide.disabled = pptData.currentSlideIndex === 0;
      elements.nextSlide.disabled = pptData.currentSlideIndex === pptData.slides.length - 1;
    }

    // 更新动画按钮状态
    function updateAnimationButtonStatus() {
      const hasAnimation = pptData.slides[pptData.currentSlideIndex]?.hasAnimation;
      if (hasAnimation) {
        elements.playAnimationBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        elements.playAnimationBtn.disabled = false;
      } else {
        elements.playAnimationBtn.classList.add('opacity-50', 'cursor-not-allowed');
        elements.playAnimationBtn.disabled = true;
      }
    }

    // 显示上一张幻灯片
    function showPrevSlide() {
      if (pptData.currentSlideIndex > 0) {
        showSlide(pptData.currentSlideIndex - 1);
      }
    }

    // 显示下一张幻灯片
    function showNextSlide() {
      if (pptData.currentSlideIndex < pptData.slides.length - 1) {
        showSlide(pptData.currentSlideIndex + 1);
      }
    }

    // 切换手写批注模式（优化触屏反馈）
    function toggleDrawingMode() {
      pptData.isDrawingMode = !pptData.isDrawingMode;
      pptData.fabricCanvas.isDrawingMode = pptData.isDrawingMode;

      if (pptData.isDrawingMode) {
        // 进入手写模式：切换光标和按钮样式
        elements.toggleDrawing.classList.remove('bg-primary/10', 'text-primary');
        elements.toggleDrawing.classList.add('bg-red-500', 'text-white');
        elements.toggleDrawing.innerHTML = '<i class="fa fa-stop text-xs mr-1"></i> 退出手写';
        document.getElementById('drawingCanvas').style.cursor = 'crosshair';
        showNotification('已进入手写模式，支持触屏绘画');
      } else {
        // 退出手写模式：保存当前批注
        pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
        elements.toggleDrawing.classList.add('bg-primary/10', 'text-primary');
        elements.toggleDrawing.classList.remove('bg-red-500', 'text-white');
        elements.toggleDrawing.innerHTML = '<i class="fa fa-pencil text-xs mr-1"></i> 手写模式';
        document.getElementById('drawingCanvas').style.cursor = 'default';
        showNotification('已退出手写模式，批注已保存');
      }
    }

    // 更新画笔颜色（适配触屏点击）
    function updateBrushColor(e) {
      // 移除所有颜色按钮的选中状态
      elements.colorButtons.forEach(btn => btn.classList.remove('border-primary', 'scale-110'));
      // 添加当前选中状态
      e.target.classList.add('border-primary', 'scale-110');
      // 更新画笔颜色
      pptData.brushColor = e.target.dataset.color;
      pptData.fabricCanvas.freeDrawingBrush.color = pptData.brushColor;
    }

    // 更新画笔粗细（适配触屏滑动）
    function updateBrushSize(e) {
      pptData.brushSize = parseInt(e.target.value);
      pptData.fabricCanvas.freeDrawingBrush.width = pptData.brushSize;
      showNotification(`画笔粗细已调整为 ${pptData.brushSize}px`);
    }

    // 清除当前幻灯片的批注
    function clearCurrentSlideAnnotations() {
      if (confirm('确定要清除当前页的所有批注吗？')) {
        pptData.slideAnnotations[pptData.currentSlideIndex] = [];
        renderCurrentSlideAnnotations();
        showNotification('当前页批注已清除');
      }
    }

    // 保存批注（生成含批注的PPT预览图打包）
    function saveAnnotations() {
      elements.saveFileBtn.disabled = true;
      elements.saveFileBtn.innerHTML = '<i class="fa fa-spinner fa-spin text-xs mr-1"></i> 保存中...';

      try {
        // 生成每个幻灯片的批注+内容合成图
        const slideImages = [];
        const originalIndex = pptData.currentSlideIndex;

        // 批量生成合成图
        const generatePromises = pptData.slides.map(async (slide, index) => {
          // 临时切换到当前幻灯片
          showSlide(index);
          // 等待DOM渲染完成
          await new Promise(resolve => setTimeout(resolve, 200));
          // 合成PPT内容和批注
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = elements.slideContent.offsetWidth;
          canvas.height = elements.slideContent.offsetHeight;

          // 绘制PPT内容（含动画当前帧）
          const contentDataUrl = await htmlToImage(elements.slideContent);
          const contentImg = new Image();
          contentImg.src = contentDataUrl;
          await new Promise(resolve => contentImg.onload = resolve);
          ctx.drawImage(contentImg, 0, 0, canvas.width, canvas.height);

          // 绘制批注
          const annotationDataUrl = pptData.fabricCanvas.toDataURL({
            format: 'png',
            quality: 1.0
          });
          const annotationImg = new Image();
          annotationImg.src = annotationDataUrl;
          await new Promise(resolve => annotationImg.onload = resolve);
          ctx.drawImage(annotationImg, 0, 0, canvas.width, canvas.height);

          slideImages.push({
            index: index + 1,
            dataUrl: canvas.toDataURL('image/png')
          });
        });

        // 所有图片生成完成后打包下载
        Promise.all(generatePromises).then(() => {
          // 切换回原始幻灯片
          showSlide(originalIndex);

          // 使用JSZip打包图片为ZIP下载
          const zip = new JSZip();
          slideImages.forEach(img => {
            const fileName = `幻灯片${img.index}_带批注.png`;
            zip.file(fileName, img.dataUrl.split(',')[1], { base64: true });
          });

          zip.generateAsync({ type: 'blob' }).then(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `PPT批注_${new Date().getTime()}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            elements.saveFileBtn.disabled = false;
            elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
            showNotification('批注保存成功，已下载为图片包');
          });
        });
      } catch (error) {
        console.error('批注保存失败:', error);
        elements.saveFileBtn.disabled = false;
        elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
        showNotification('批注保存失败', 'error');
      }
    }

    // HTML转Image（用于合成PPT内容和批注）
    function htmlToImage(element) {
      return new Promise((resolve) => {
        // 使用html2canvas简化实现（实际项目建议引入html2canvas库）
        // 此处为兼容代码，实际使用时需引入：<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
        if (window.html2canvas) {
          html2canvas(element, {
            scale: 2, // 提高分辨率
            useCORS: true,
            logging: false
          }).then(canvas => {
            resolve(canvas.toDataURL('image/png'));
          });
        } else {
          // 降级方案：直接截图（可能丢失样式）
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = element.offsetWidth;
          canvas.height = element.offsetHeight;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/png'));
        }
      });
    }

    // 切换全屏
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.getElementById('slideContainer').requestFullscreen().catch(error => {
          showNotification('全屏切换失败', 'error');
        });
      } else {
        document.exitFullscreen();
      }
    }

    // 更新全屏按钮样式
    function updateFullscreenBtn() {
      if (document.fullscreenElement) {
        elements.fullscreenBtn.innerHTML = '<i class="fa fa-compress text-xs mr-1"></i> 退出全屏';
      } else {
        elements.fullscreenBtn.innerHTML = '<i class="fa fa-expand text-xs mr-1"></i> 全屏';
      }
    }

    // 显示通知提示
    function showNotification(message, type = 'success') {
      // 创建临时通知元素
      const notification = document.createElement('div');
      notification.className = `fixed bottom-4 right-4 px-4 py-2 rounded-md text-sm z-50 transition-all duration-300 transform translate-y-0 opacity-100 ${
        type === 'error' ? 'bg-red-500 text-white' : 'bg-green-500 text-white'
      }`;
      notification.textContent = message;
      document.body.appendChild(notification);

      // 3秒后自动消失
      setTimeout(() => {
        notification.classList.add('opacity-0', 'translate-y-4');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // 启动应用
    window.addEventListener('DOMContentLoaded', init);
  </script>
</html>
    // 修复Windows11触屏绘画线条断裂问题：优化Fabric画笔事件
    function optimizeTouchDrawing() {
      let isTouchDrawing = false;
      const canvasDom = document.getElementById('drawingCanvas');

      // 增强触摸事件处理，避免线条断裂
      canvasDom.addEventListener('touchstart', (e) => {
        if (!pptData.isDrawingMode) return;
        e.preventDefault();
        isTouchDrawing = true;
        const touch = e.touches[0];
        // 模拟鼠标按下+移动初始点，确保线条起始流畅
        const mouseDownEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true,
          cancelable: true,
          view: window
        });
        canvasDom.dispatchEvent(mouseDownEvent);

        const mouseMoveEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true,
          cancelable: true,
          view: window
        });
        canvasDom.dispatchEvent(mouseMoveEvent);
      });

      // 优化触摸移动事件，提升采样率
      canvasDom.addEventListener('touchmove', (e) => {
        if (!pptData.isDrawingMode || !isTouchDrawing) return;
        e.preventDefault();
        const touch = e.touches[0];
        // 增加移动事件触发频率，避免线条断裂
        requestAnimationFrame(() => {
          const mouseMoveEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY,
            bubbles: true,
            cancelable: true,
            view: window
          });
          canvasDom.dispatchEvent(mouseMoveEvent);
        });
      });

      // 修复触摸结束时线条不闭合问题
      canvasDom.addEventListener('touchend', (e) => {
        if (!pptData.isDrawingMode || !isTouchDrawing) return;
        e.preventDefault();
        isTouchDrawing = false;
        const touch = e.changedTouches[0];
        const mouseUpEvent = new MouseEvent('mouseup', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true,
          cancelable: true,
          view: window
        });
        canvasDom.dispatchEvent(mouseUpEvent);

        // 额外触发一次鼠标离开事件，确保画笔状态重置
        const mouseOutEvent = new MouseEvent('mouseout', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true,
          cancelable: true,
          view: window
        });
        canvasDom.dispatchEvent(mouseOutEvent);
      });

      // 处理触摸取消事件（如来电打断）
      canvasDom.addEventListener('touchcancel', (e) => {
        if (!pptData.isDrawingMode || !isTouchDrawing) return;
        isTouchDrawing = false;
        const mouseUpEvent = new MouseEvent('mouseup', {
          bubbles: true,
          cancelable: true,
          view: window
        });
        canvasDom.dispatchEvent(mouseUpEvent);
      });
    }

    // 补充：Windows11风格右键菜单（仅保留批注相关功能）
    function initContextMenu() {
      const canvasDom = document.getElementById('drawingCanvas');
      canvasDom.addEventListener('contextmenu', (e) => {
        e.preventDefault(); // 禁用默认右键菜单
        if (!pptData.isFileLoaded) return;

        // 创建自定义右键菜单
        const menu = document.createElement('div');
        menu.className = 'fixed bg-white shadow-lg rounded-md p-1 z-50 w-40 text-sm border border-gray-200';
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
        menu.innerHTML = `
          <div class="px-3 py-1.5 cursor-pointer hover:bg-gray-100 rounded" id="ctxClear">清除当前页批注</div>
          <div class="px-3 py-1.5 cursor-pointer hover:bg-gray-100 rounded" id="ctxToggleDrawing">${pptData.isDrawingMode ? '退出手写模式' : '进入手写模式'}</div>
          <div class="px-3 py-1.5 cursor-pointer hover:bg-gray-100 rounded" id="ctxSave">保存所有批注</div>
        `;

        // 绑定菜单事件
        menu.querySelector('#ctxClear').addEventListener('click', () => {
          clearCurrentSlideAnnotations();
          document.body.removeChild(menu);
        });
        menu.querySelector('#ctxToggleDrawing').addEventListener('click', () => {
          toggleDrawingMode();
          document.body.removeChild(menu);
        });
        menu.querySelector('#ctxSave').addEventListener('click', () => {
          saveAnnotations();
          document.body.removeChild(menu);
        });

        // 点击其他区域关闭菜单
        document.addEventListener('click', closeMenu);
        function closeMenu() {
          document.body.removeChild(menu);
          document.removeEventListener('click', closeMenu);
        }

        document.body.appendChild(menu);
      });
    }

    // 补充：幻灯片切换动画（Windows11风格淡入淡出）
    function addSlideTransition() {
      const slideContent = document.getElementById('slideContent');
      slideContent.style.transition = 'opacity 0.3s ease';

      // 重写showSlide函数，添加过渡效果
      const originalShowSlide = showSlide;
      window.showSlide = function(index) {
        if (index < 0 || index >= pptData.slides.length) return;

        // 保存当前批注
        if (pptData.currentSlideIndex >= 0 && pptData.currentSlideIndex < pptData.slideAnnotations.length) {
          pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
        }

        // 淡出当前幻灯片
        slideContent.style.opacity = '0';

        setTimeout(() => {
          // 执行原始切换逻辑
          originalShowSlide(index);
          // 淡入新幻灯片
          slideContent.style.opacity = '1';
        }, 200);
      };
    }

    // 补充：Windows11触屏手势支持（左右滑动切换幻灯片）
    function initSwipeGesture() {
      const slideContainer = document.getElementById('slideContainer');
      let startX = 0;
      let isSwiping = false;

      slideContainer.addEventListener('touchstart', (e) => {
        if (pptData.isDrawingMode) return; // 手写模式下禁用滑动
        startX = e.touches[0].clientX;
        isSwiping = true;
      });

      slideContainer.addEventListener('touchmove', (e) => {
        if (!isSwiping || pptData.isDrawingMode) return;
        const currentX = e.touches[0].clientX;
        const diffX = currentX - startX;

        // 滑动距离阈值（50px），避免误触
        if (Math.abs(diffX) > 50) {
          isSwiping = false;
          if (diffX > 0) {
            // 向右滑动：上一张
            showPrevSlide();
          } else {
            // 向左滑动：下一张
            showNextSlide();
          }
        }
      });

      slideContainer.addEventListener('touchend', () => {
        isSwiping = false;
      });

      slideContainer.addEventListener('touchcancel', () => {
        isSwiping = false;
      });
    }

    // 修复：Windows11下PPT动画层级问题（避免批注遮挡动画）
    function fixAnimationZIndex() {
      // 监听幻灯片内容变化，确保动画元素层级低于批注
      const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          if (mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === 1 && (node.hasAttribute('data-animation') || node.tagName === 'ANIMATION')) {
                node.style.zIndex = '1'; // 动画元素层级低于批注（z-index:10）
              }
            });
          }
        });
      });

      observer.observe(document.getElementById('slideContent'), {
        childList: true,
        subtree: true
      });
    }

    // 补充：批注自动保存功能（避免意外丢失）
    function initAutoSave() {
      let autoSaveTimer;
      // 切换幻灯片时触发自动保存
      const originalShowSlide = window.showSlide;
      window.showSlide = function(index) {
        // 自动保存当前页批注
        if (pptData.currentSlideIndex >= 0 && pptData.currentSlideIndex < pptData.slideAnnotations.length) {
          pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
        }
        originalShowSlide(index);
      };

      // 手写模式下每3秒自动保存一次
      pptData.fabricCanvas.on('path:created', () => {
        if (pptData.isDrawingMode) {
          clearTimeout(autoSaveTimer);
          autoSaveTimer = setTimeout(() => {
            pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
          }, 3000);
        }
      });

      // 页面关闭前提示保存
      window.addEventListener('beforeunload', (e) => {
        const hasAnnotations = pptData.slideAnnotations.some(annotations => annotations.length > 0);
        if (hasAnnotations) {
          e.preventDefault();
          e.returnValue = '您有未保存的批注，是否确认离开？';
          return '您有未保存的批注，是否确认离开？';
        }
      });
    }

    // 重写初始化函数，整合所有优化功能
    function init() {
      // 绑定所有事件监听（移除编辑相关事件）
      bindAllEvents();
      // 初始化Fabric画布（优化Windows11触屏）
      initFabricCanvas();
      // 优化Windows11触屏绘画（修复线条断裂）
      optimizeTouchDrawing();
      // 初始化右键菜单
      initContextMenu();
      // 添加幻灯片切换动画
      addSlideTransition();
      // 初始化滑动手势
      initSwipeGesture();
      // 修复动画层级问题
      fixAnimationZIndex();
      // 初始化自动保存
      initAutoSave();
      // 默认选中第一个画笔颜色
      elements.colorButtons[0].classList.add('border-primary', 'scale-110');
      // 监听窗口滚动，优化导航栏样式
      window.addEventListener('scroll', () => {
        if (window.scrollY > 10) {
          elements.header.classList.add('py-2', 'shadow');
          elements.header.classList.remove('py-3', 'shadow-sm');
        } else {
          elements.header.classList.add('py-3', 'shadow-sm');
          elements.header.classList.remove('py-2', 'shadow');
        }
      });

      // 检测Windows11系统，显示适配提示
      if (navigator.userAgent.includes('Windows NT 10.0; Win64; x64') || navigator.userAgent.includes('Windows 11')) {
        setTimeout(() => {
          showNotification('已适配Windows11触屏，支持手写批注和滑动导航', 'info');
        }, 1000);
      }
    }

    // 修复：HTML转Image函数（提升Windows11下兼容性和清晰度）
    function htmlToImage(element) {
      return new Promise((resolve) => {
        if (!window.html2canvas) {
          // 降级方案：确保图片清晰度
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const rect = element.getBoundingClientRect();
          canvas.width = rect.width * window.devicePixelRatio;
          canvas.height = rect.height * window.devicePixelRatio;
          ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, rect.width, rect.height);
          
          // 尝试绘制DOM内容（简化版）
          try {
            const svg = new XMLSerializer().serializeToString(element);
            const img = new Image();
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
            img.onload = () => {
              ctx.drawImage(img, 0, 0);
              resolve(canvas.toDataURL('image/png', 1.0));
            };
            img.onerror = () => {
              resolve(canvas.toDataURL('image/png', 1.0));
            };
          } catch (e) {
            resolve(canvas.toDataURL('image/png', 1.0));
          }
          return;
        }

        // 优化html2canvas配置（Windows11下提升兼容性）
        html2canvas(element, {
          scale: window.devicePixelRatio || 2, // 适配高DPI屏幕
          useCORS: true,
          logging: false,
          allowTaint: false,
          backgroundColor: '#ffffff',
          windowWidth: element.offsetWidth,
          windowHeight: element.offsetHeight,
          scrollX: -window.scrollX,
          scrollY: -window.scrollY,
          // 修复Windows11下字体渲染问题
          letterRendering: true,
          ignoreElements: (el) => {
            // 忽略canvas元素（避免批注重复绘制）
            return el.id === 'drawingCanvas';
          }
        }).then(canvas => {
          resolve(canvas.toDataURL('image/png', 1.0));
        }).catch((error) => {
          console.error('html2canvas转换失败:', error);
          // 降级处理
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = element.offsetWidth;
          canvas.height = element.offsetHeight;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/png', 1.0));
        });
      });
    }

    // 修复：保存批注函数（优化Windows11下ZIP生成速度）
    function saveAnnotations() {
      elements.saveFileBtn.disabled = true;
      elements.saveFileBtn.innerHTML = '<i class="fa fa-spinner fa-spin text-xs mr-1"></i> 保存中...';

      try {
        // 生成每个幻灯片的批注+内容合成图（并行处理，提升速度）
        const slideImages = [];
        const originalIndex = pptData.currentSlideIndex;
        const totalSlides = pptData.slides.length;

        // 批量生成合成图（限制并发数为3，避免Windows11下卡顿）
        const concurrencyLimit = 3;
        let currentIndex = 0;

        function processSlide() {
          if (currentIndex >= totalSlides) {
            // 所有幻灯片处理完成
            generateZipFile(slideImages);
            showSlide(originalIndex);
            return;
          }

          const index = currentIndex;
          currentIndex++;

          // 临时切换到当前幻灯片
          showSlide(index);

          // 等待DOM渲染完成
          setTimeout(() => {
            // 合成PPT内容和批注
            Promise.all([
              htmlToImage(elements.slideContent),
              new Promise(resolve => {
                resolve(pptData.fabricCanvas.toDataURL({
                  format: 'png',
                  quality: 1.0
                }));
              })
            ]).then(([contentDataUrl, annotationDataUrl]) => {
              slideImages.push({
                index: index + 1,
                contentDataUrl: contentDataUrl,
                annotationDataUrl: annotationDataUrl
              });

              // 继续处理下一个幻灯片
              processSlide();
            });
          }, 150);
        }

        // 启动并发处理
        for (let i = 0; i < concurrencyLimit; i++) {
          processSlide();
        }
      } catch (error) {
        console.error('批注保存失败:', error);
        elements.saveFileBtn.disabled = false;
        elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
        showNotification('批注保存失败', 'error');
      }
    }

    // 优化：生成ZIP文件（Windows11下提升兼容性）
    function generateZipFile(slideImages) {
      const zip = new JSZip();
      const date = new Date().toLocaleDateString().replace(/\//g, '-');
      const baseFolder = `PPT批注_${date}`;

      // 创建文件夹结构
      const contentFolder = zip.folder(`${baseFolder}/原始幻灯片`);
      const annotationFolder = zip.folder(`${baseFolder}/带批注幻灯片`);

      // 添加图片文件
      slideImages.forEach(img => {
        // 原始幻灯片图片
        const contentBase64 = img.contentDataUrl.split(',')[1];
        contentFolder.file(`幻灯片${img.index}.png`, contentBase64, { base64: true });

        // 带批注幻灯片图片（合成）
        const annotationBase64 = img.annotationDataUrl.split(',')[1];
        annotationFolder.file(`幻灯片${img.index}_带批注.png`, annotationBase64, { base64: true });
      });

      // 生成ZIP文件（优化Windows11下下载体验）
      zip.generateAsync({ 
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 } // 平衡压缩速度和体积
      }).then(function(content) {
        // 创建下载链接（适配Windows11浏览器）
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${baseFolder}.zip`;
        // 模拟点击下载（解决Edge浏览器下载问题）
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
        }, 1000);

        elements.saveFileBtn.disabled = false;
        elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
        showNotification('批注保存成功，已生成ZIP包', 'success');
      }).catch(function(error) {
        console.error('ZIP生成失败:', error);
        elements.saveFileBtn.disabled = false;
        elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
        showNotification('ZIP包生成失败，请重试', 'error');
      });
    }

    // 补充：Windows11风格通知提示（优化视觉体验）
    function showNotification(message, type = 'success') {
      // 移除现有通知
      const existingNotifications = document.querySelectorAll('.custom-notification');
      existingNotifications.forEach(notify => notify.remove());

      // 创建通知元素（Windows11风格）
      const notification = document.createElement('div');
      const iconClass = type === 'success' ? 'fa-check-circle' :
                       type === 'error' ? 'fa-exclamation-circle' :
                       type === 'info' ? 'fa-info-circle' : 'fa-warning';
      const bgColor = type === 'success' ? 'bg-green-500' :
                     type === 'error' ? 'bg-red-500' :
                     type === 'info' ? 'bg-blue-500' : 'bg-yellow-500';

      notification.className = `custom-notification fixed bottom-4 right-4 px-4 py-3 rounded-md ${bgColor} text-white text-sm shadow-lg z-50 transition-all duration-300 transform translate-y-0 opacity-100 flex items-center`;
      notification.innerHTML = `
        <i class="fa ${iconClass} mr-2 text-base"></i>
        <span>${message}</span>
        <button class="ml-2 text-white/80 hover:text-white">
          <i class="fa fa-times text-xs"></i>
        </button>
      `;

      // 关闭按钮事件
      notification.querySelector('button').addEventListener('click', () => {
        notification.classList.add('opacity-0', 'translate-y-4');
        setTimeout(() => notification.remove(), 300);
      });

      // 添加到文档
      document.body.appendChild(notification);

      // 自动关闭（5秒）
      setTimeout(() => {
        notification.classList.add('opacity-0', 'translate-y-4');
        setTimeout(() => {
          if (document.body.contains(notification)) {
            document.body.removeChild(notification);
          }
        }, 300);
      }, 5000);
    }
              // 修复：Windows11下全屏模式批注位置偏移问题
    function fixFullscreenAnnotationOffset() {
      let isFullscreen = false;
      let scaleRatio = { x: 1, y: 1 };

      // 监听全屏状态变化
      document.addEventListener('fullscreenchange', updateFullscreenScale);
      window.addEventListener('resize', () => {
        if (isFullscreen) updateFullscreenScale();
      });

      function updateFullscreenScale() {
        isFullscreen = !!document.fullscreenElement;
        const slideContainer = document.getElementById('slideContainer');
        const canvasDom = document.getElementById('drawingCanvas');

        if (isFullscreen) {
          // 计算全屏模式下的缩放比例（解决批注位置偏移）
          const containerRect = slideContainer.getBoundingClientRect();
          const canvasRect = canvasDom.getBoundingClientRect();
          scaleRatio.x = containerRect.width / canvasRect.width;
          scaleRatio.y = containerRect.height / canvasRect.height;

          // 调整画布坐标系统
          pptData.fabricCanvas.setWidth(containerRect.width);
          pptData.fabricCanvas.setHeight(containerRect.height);
          pptData.fabricCanvas.setZoom(1);

          // 重新渲染批注，适配全屏尺寸
          renderCurrentSlideAnnotations();
        } else {
          // 退出全屏，恢复原始比例
          const containerRect = slideContainer.getBoundingClientRect();
          pptData.fabricCanvas.setWidth(containerRect.width);
          pptData.fabricCanvas.setHeight(containerRect.height);
          renderCurrentSlideAnnotations();
        }
      }

      // 重写Fabric画笔坐标计算，适配全屏缩放
      const originalCreatePath = pptData.fabricCanvas.freeDrawingBrush.createPath;
      pptData.fabricCanvas.freeDrawingBrush.createPath = function(points) {
        if (isFullscreen) {
          // 修正全屏模式下的坐标
          const scaledPoints = points.map(point => ({
            x: point.x * scaleRatio.x,
            y: point.y * scaleRatio.y
          }));
          return originalCreatePath.call(this, scaledPoints);
        }
        return originalCreatePath.call(this, points);
      };
    }

    // 修复：PPT动画播放时批注遮挡问题
    function fixAnimationOverlay() {
      const slideContent = document.getElementById('slideContent');
      const canvasDom = document.getElementById('drawingCanvas');

      // 监听动画元素添加事件
      const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          if (mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === 1 && (node.style.animation || node.hasAttribute('data-animation'))) {
                // 确保动画元素层级低于批注
                node.style.zIndex = '1';
                // 确保批注画布始终在最上层
                canvasDom.style.zIndex = '10';
              }
            });
          }
        });
      });

      observer.observe(slideContent, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'data-animation']
      });
    }

    // 优化：Windows11低性能设备适配（降低资源占用）
    function optimizeLowPerformanceDevices() {
      // 检测设备性能，调整画笔参数
      const isLowPerformance = navigator.hardwareConcurrency <= 4 || screen.width < 1080;
      if (isLowPerformance) {
        // 降低画笔采样率，减少内存占用
        pptData.fabricCanvas.freeDrawingBrush.decimate = 2;
        // 限制最大画笔粗细
        elements.brushSize.max = 8;
        // 关闭硬件加速（部分低性能设备兼容）
        pptData.fabricCanvas.disableStyleCache = true;
        showNotification('已适配低性能设备，优化运行流畅度', 'info');
      }
    }

    // 修复：幻灯片切换时批注残留问题
    function fixAnnotationPersistence() {
      // 重写renderCurrentSlideAnnotations，确保清空画布
      const originalRender = renderCurrentSlideAnnotations;
      window.renderCurrentSlideAnnotations = function() {
        // 强制清空画布（解决残留问题）
        pptData.fabricCanvas.clear();
        pptData.fabricCanvas.renderAll();
        // 延迟渲染批注，避免切换时闪烁
        setTimeout(() => {
          originalRender.call(this);
        }, 50);
      };
    }

    // 补充：错误处理与容错机制
    function initErrorHandling() {
      // 捕获PPT解析错误
      window.addEventListener('unhandledrejection', (event) => {
        if (event.reason.message.includes('PPT') || event.reason.message.includes('slide')) {
          event.preventDefault();
          showNotification('PPT解析或渲染出错，请尝试重新上传文件', 'error');
          // 重置UI状态
          elements.loadingArea.classList.add('hidden');
          elements.uploadArea.classList.remove('hidden');
        }
      });

      // 捕获画布操作错误
      pptData.fabricCanvas.on('error', (error) => {
        console.error('画布操作错误:', error);
        showNotification('批注操作出错，请重试', 'error');
      });

      // 文件上传大小限制（补充100MB限制）
      elements.fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file && file.size > 1024 * 1024 * 100) { // 100MB
          showNotification('文件大小超过100MB限制，请上传更小的文件', 'error');
          elements.fileInput.value = '';
        }
      });
    }

    // 最终整合：更新初始化函数，包含所有修复
    function init() {
      // 绑定所有事件监听（移除编辑相关事件）
      bindAllEvents();
      // 初始化Fabric画布（优化Windows11触屏）
      initFabricCanvas();
      // 优化Windows11触屏绘画（修复线条断裂）
      optimizeTouchDrawing();
      // 初始化右键菜单
      initContextMenu();
      // 添加幻灯片切换动画
      addSlideTransition();
      // 初始化滑动手势
      initSwipeGesture();
      // 修复动画层级问题
      fixAnimationZIndex();
      // 初始化自动保存
      initAutoSave();
      // 修复全屏批注偏移
      fixFullscreenAnnotationOffset();
      // 修复动画遮挡问题
      fixAnimationOverlay();
      // 适配低性能设备
      optimizeLowPerformanceDevices();
      // 修复批注残留问题
      fixAnnotationPersistence();
      // 初始化错误处理
      initErrorHandling();
      // 默认选中第一个画笔颜色
      elements.colorButtons[0].classList.add('border-primary', 'scale-110');
      // 监听窗口滚动，优化导航栏样式
      window.addEventListener('scroll', () => {
        if (window.scrollY > 10) {
          elements.header.classList.add('py-2', 'shadow');
          elements.header.classList.remove('py-3', 'shadow-sm');
        } else {
          elements.header.classList.add('py-3', 'shadow-sm');
          elements.header.classList.remove('py-2', 'shadow');
        }
      });

      // 检测Windows11系统，显示适配提示
      if (navigator.userAgent.includes('Windows NT 10.0; Win64; x64') || navigator.userAgent.includes('Windows 11')) {
        setTimeout(() => {
          showNotification('已适配Windows11触屏，支持手写批注和滑动导航', 'info');
        }, 1000);
      }
    }

    // 补充：手动触发动画重置功能（解决动画重复播放问题）
    function resetCurrentSlideAnimation() {
      const slide = pptData.slides[pptData.currentSlideIndex];
      if (!slide.hasAnimation) return;

      try {
        // 重置动画元素状态
        const animationElements = elements.slideContent.querySelectorAll('[data-animation], [style*="animation"]');
        animationElements.forEach(el => {
          el.style.animationPlayState = 'paused';
          el.style.animation = 'none';
          // 强制重绘
          void el.offsetWidth;
          el.style.animation = null;
          el.style.animationPlayState = 'paused';
        });

        // 重置pptxjs动画函数状态
        const resetFunction = window[`slide${pptData.currentSlideIndex}_reset`];
        if (typeof resetFunction === 'function') {
          resetFunction();
        }

        showNotification('动画已重置，可重新播放');
      } catch (error) {
        console.error('动画重置失败:', error);
        showNotification('动画重置失败', 'error');
      }
    }

    // 绑定动画重置事件（双击幻灯片空白处重置动画）
    elements.slideContent.addEventListener('dblclick', (e) => {
      if (e.target === elements.slideContent || e.target.classList.contains('slide-background')) {
        resetCurrentSlideAnimation();
      }
    });

    // 最终：启动应用（确保DOM完全加载）
    document.addEventListener('DOMContentLoaded', () => {
      // 确保所有依赖加载完成后初始化
      const checkDependencies = setInterval(() => {
        if (window.PPTX && window.fabric && window.JSZip && window.html2canvas) {
          clearInterval(checkDependencies);
          init();
        }
      }, 100);

      // 依赖加载超时处理（5秒）
      setTimeout(() => {
        if (!window.PPTX || !window.fabric || !window.JSZip || !window.html2canvas) {
          clearInterval(checkDependencies);
          showNotification('核心依赖加载超时，请刷新页面重试', 'error');
        }
      }, 5000);
    });
  </script>
</body>
</html>
