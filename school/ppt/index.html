<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>PPT|FlyzOffice</title>
  <!-- 核心依赖（严格控制加载顺序：基础样式→工具库→PPT解析库→画布库→截图库） -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/es6-promise@4.2.8/dist/es6-promise.auto.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxjs@1.4.1/dist/pptx.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pptxjs@1.4.1/dist/pptx.css">
  <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <!-- Tailwind配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#2563eb',
            neutral: '#f8fafc'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>

  <!-- Tailwind自定义工具类 -->
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .transition-base {
        transition: all 0.2s ease;
      }
      .shadow-light {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      .touch-optimized {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
    }
  </style>

  <!-- 基础样式（全局统一，无冗余） -->
  <style>
    body {
      font-feature-settings: "cv02", "cv03", "cv04", "cv11";
      overflow-x: hidden;
    }
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: crosshair;
      touch-action: none;
      z-index: 10;
      -webkit-user-select: none;
      user-select: none;
    }
    :-webkit-full-screen {
      background-color: white;
    }
    :fullscreen {
      background-color: white;
    }
    .loader {
      border-top-color: #2563eb;
      animation: spinner 0.6s linear infinite;
    }
    @keyframes spinner {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .thumbnail-item {
      transition: all 0.15s ease;
    }
    .thumbnail-item.active {
      ring: 2px ring-primary;
    }
    .thumbnail-item:hover:not(.active) {
      ring: 2px ring-gray-300;
    }
    #slideContent {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      overflow: hidden;
    }
    .touch-btn {
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    [data-color] {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      transition: all 0.1s ease;
    }
    [data-color]:active {
      transform: scale(0.9);
    }
    input[type="range"] {
      -webkit-appearance: none;
      height: 4px;
      border-radius: 2px;
      background: #e2e8f0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #2563eb;
      cursor: pointer;
      transition: all 0.1s ease;
    }
    input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(1.2);
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 16px;
      border-radius: 6px;
      background: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 9999;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .notification.error {
      background: #fee2e2;
      color: #dc2626;
    }
    .notification.success {
      background: #dcfce7;
      color: #16a34a;
    }
  </style>
</head>
<body class="font-sans bg-neutral text-gray-800 min-h-screen flex flex-col">
  <!-- 顶部导航栏 -->
  <header class="bg-white shadow-sm sticky top-0 z-50 transition-all duration-300">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <div class="flex items-center space-x-3">
        <div class="w-10 h-10 rounded-md overflow-hidden border border-gray-100 shadow-sm">
          <img src="https://www.img520.com/UIGuUV.jpeg" alt="PPT工具Logo" class="w-full h-full object-cover">
        </div>
        <h1 class="text-lg font-semibold text-gray-800">FlyzOffice</h1>
      </div>
      <div class="flex items-center space-x-3">
        <button id="uploadBtn" class="flex items-center space-x-1 bg-primary hover:bg-primary/90 text-white px-3 py-1.5 rounded-md text-sm transition-base touch-optimized">
          <i class="fa fa-upload text-xs"></i>
          <span>上传PPT</span>
        </button>
        <input type="file" id="fileInput" accept=".pptx" class="hidden">
        <button id="saveFileBtn" class="flex items-center space-x-1 bg-green-500 hover:bg-green-600 text-white px-3 py-1.5 rounded-md text-sm transition-base hidden touch-optimized" disabled>
          <i class="fa fa-save text-xs"></i>
          <span>保存批注</span>
        </button>
      </div>
    </div>
  </header>

  <!-- 主内容区 -->
  <main class="flex-1 container mx-auto px-4 py-6 flex flex-col lg:flex-row gap-6">
    <!-- 左侧上传区域 -->
    <div id="uploadArea" class="lg:w-1/4 bg-white rounded-xl shadow-light p-6 flex flex-col items-center justify-center text-center">
      <div class="w-20 h-20 bg-primary/5 rounded-full flex items-center justify-center mb-4">
        <i class="fa fa-file-powerpoint-o text-primary text-3xl"></i>
      </div>
      <h2 class="text-lg font-medium mb-2">上传PPT文件</h2>
      <p class="text-gray-500 text-sm mb-6">支持Win11触屏绘画 | 保留批注 | 原动画不变</p>
      <label for="fileInput" class="cursor-pointer bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-base flex items-center space-x-2 touch-optimized">
        <i class="fa fa-upload"></i>
        <span>选择文件</span>
      </label>
      <p class="text-xs text-gray-400 mt-3">最大支持666页以内文件</p>
    </div>

    <!-- 左侧工具栏 -->
    <div id="toolSidebar" class="lg:w-1/4 hidden flex-col gap-4">
      <!-- 幻灯片导航 -->
      <div class="bg-white rounded-xl shadow-light p-4">
        <h3 class="font-medium text-gray-700 text-sm mb-3 flex items-center">
          <i class="fa fa-th-list text-primary mr-1.5 text-xs"></i>
          幻灯片导航
        </h3>
        <div id="thumbnailContainer" class="grid grid-cols-2 gap-2 max-h-[300px] overflow-y-auto p-1"></div>
      </div>

      <!-- 批注工具 -->
      <div class="bg-white rounded-xl shadow-light p-4">
        <h3 class="font-medium text-gray-700 text-sm mb-3 flex items-center">
          <i class="fa fa-paint-brush text-primary mr-1.5 text-xs"></i>
          批注工具
        </h3>
        <div class="space-y-3">
          <div>
            <label class="block text-xs text-gray-500 mb-1.5">画笔颜色</label>
            <div class="flex space-x-2">
              <button class="w-7 h-7 rounded-full bg-red-500 border-2 border-primary scale-110 transition-base" data-color="#ef4444"></button>
              <button class="w-7 h-7 rounded-full bg-blue-500 border-2 border-transparent hover:scale-110 transition-base" data-color="#3b82f6"></button>
              <button class="w-7 h-7 rounded-full bg-green-500 border-2 border-transparent hover:scale-110 transition-base" data-color="#22c55e"></button>
              <button class="w-7 h-7 rounded-full bg-yellow-500 border-2 border-transparent hover:scale-110 transition-base" data-color="#eab308"></button>
              <button class="w-7 h-7 rounded-full bg-black border-2 border-transparent hover:scale-110 transition-base" data-color="#000000"></button>
            </div>
          </div>
          <div>
            <label class="block text-xs text-gray-500 mb-1.5">画笔粗细</label>
            <input type="range" id="brushSize" min="2" max="10" value="3" class="w-full accent-primary">
            <div class="flex justify-between text-xs text-gray-400 mt-1">
              <span>细</span>
              <span>粗</span>
            </div>
          </div>
          <div class="flex space-x-2">
            <button id="clearAnnotations" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 px-2 py-2 rounded-md text-sm transition-base touch-optimized">
              <i class="fa fa-eraser text-xs mr-1"></i> 清除当前页
            </button>
            <button id="toggleDrawing" class="flex-1 bg-primary text-white px-2 py-2 rounded-md text-sm transition-base touch-optimized">
              <i class="fa fa-pencil text-xs mr-1"></i> 手写模式
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- 右侧PPT预览区 -->
    <div id="pptEditor" class="lg:w-3/4 bg-white rounded-xl shadow-light p-4 flex flex-col items-center justify-center hidden">
      <div class="relative w-full max-w-3xl aspect-[16/9] bg-white rounded-lg overflow-hidden border border-gray-200" id="slideContainer">
        <div id="slideContent" class="w-full h-full"></div>
        <canvas id="drawingCanvas" class="w-full h-full"></canvas>
      </div>
      <!-- 控制栏 -->
      <div class="mt-4 flex items-center justify-between w-full max-w-3xl">
        <div class="flex items-center space-x-4">
          <button id="prevSlide" class="p-3 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-700 transition-base disabled:opacity-50 disabled:cursor-not-allowed touch-btn" disabled>
            <i class="fa fa-chevron-left"></i>
          </button>
          <span id="slideCounter" class="text-gray-500 text-sm min-w-[60px] text-center">1 / 0</span>
          <button id="nextSlide" class="p-3 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-700 transition-base disabled:opacity-50 disabled:cursor-not-allowed touch-btn" disabled>
            <i class="fa fa-chevron-right"></i>
          </button>
        </div>
        <div class="flex items-center space-x-3">
          <button id="playAnimationBtn" class="px-4 py-2 rounded-md bg-primary/10 hover:bg-primary/20 text-primary text-sm transition-base touch-optimized">
            <i class="fa fa-play text-xs mr-1"></i> 播放动画
          </button>
          <button id="fullscreenBtn" class="px-4 py-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700 text-sm transition-base touch-optimized">
            <i class="fa fa-expand text-xs mr-1"></i> 全屏
          </button>
        </div>
      </div>
    </div>

    <!-- 加载状态 -->
    <div id="loadingArea" class="lg:w-3/4 hidden flex-col items-center justify-center bg-white rounded-xl shadow-light p-6">
      <div class="loader w-10 h-10 border-3 border-gray-100 rounded-full mb-3"></div>
      <h3 class="text-base font-medium text-gray-700">正在解析文件...</h3>
      <p class="text-gray-500 text-sm mt-1" id="loadingProgress">处理中，请稍候</p>
    </div>
  </main>

  <!-- 页脚 -->
  <footer class="bg-white border-t border-gray-100 py-3 mt-6">
    <div class="container mx-auto px-4 text-center text-gray-500 text-xs">
      <p>版本V1.0.1_20251113 | Flyz远征飞官方出品 | 适配Windows11触屏</p>
    </div>
  </footer>

  <!-- 通知容器 -->
  <div id="notificationContainer"></div>

  <script>
    // 全局核心变量（唯一声明，无重复）
    const pptData = {
      slides: [], // 存储幻灯片数据（含原动画HTML）
      currentSlideIndex: 0, // 当前幻灯片索引
      isDrawingMode: false, // 手写模式状态
      brushColor: '#ef4444', // 默认画笔颜色
      brushSize: 3, // 默认画笔粗细
      fabricCanvas: null, // Fabric画布实例
      slideAnnotations: [], // 各幻灯片批注数据
      isFileLoaded: false, // PPT加载状态
      pptRenderer: null // PPT解析渲染器
    };

    // DOM元素缓存（唯一缓存，避免重复查询）
    const elements = {
      fileInput: document.getElementById('fileInput'),
      uploadBtn: document.getElementById('uploadBtn'),
      uploadArea: document.getElementById('uploadArea'),
      toolSidebar: document.getElementById('toolSidebar'),
      pptEditor: document.getElementById('pptEditor'),
      loadingArea: document.getElementById('loadingArea'),
      thumbnailContainer: document.getElementById('thumbnailContainer'),
      slideContent: document.getElementById('slideContent'),
      slideCounter: document.getElementById('slideCounter'),
      prevSlide: document.getElementById('prevSlide'),
      nextSlide: document.getElementById('nextSlide'),
      toggleDrawing: document.getElementById('toggleDrawing'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      clearAnnotations: document.getElementById('clearAnnotations'),
      saveFileBtn: document.getElementById('saveFileBtn'),
      brushSize: document.getElementById('brushSize'),
      colorButtons: document.querySelectorAll('[data-color]'),
      loadingProgress: document.getElementById('loadingProgress'),
      header: document.querySelector('header'),
      playAnimationBtn: document.getElementById('playAnimationBtn'),
      notificationContainer: document.getElementById('notificationContainer')
    };

    // 初始化入口函数（唯一执行）
    function init() {
      // 检查核心依赖加载状态
      checkDependencies();
      // 绑定事件监听
      bindBaseEvents();
      // 初始化画布
      initFabricCanvas();
      // 监听窗口滚动
      window.addEventListener('scroll', updateHeaderStyle);
    }

    // 检查核心依赖是否加载完成
    function checkDependencies() {
      const requiredLibs = [
        { name: 'JSZip', lib: window.JSZip },
        { name: 'PPTX', lib: window.PPTX },
        { name: 'fabric', lib: window.fabric },
        { name: 'html2canvas', lib: window.html2canvas }
      ];
      const missingLibs = requiredLibs.filter(item => !item.lib).map(item => item.name);
      
      if (missingLibs.length > 0) {
        showNotification(`核心依赖加载失败：${missingLibs.join(', ')}`, 'error');
        elements.uploadBtn.disabled = true;
        elements.uploadBtn.classList.add('opacity-50', 'cursor-not-allowed');
      }
    }

    // 绑定基础事件（无重复绑定）
    function bindBaseEvents() {
      // 文件上传事件
      elements.uploadBtn.addEventListener('click', () => elements.fileInput.click());
      elements.fileInput.addEventListener('change', handlePPTUpload);

      // 全屏相关事件
      elements.fullscreenBtn.addEventListener('click', toggleFullscreen);
      document.addEventListener('fullscreenchange', updateFullscreenBtn);

      // 导航栏滚动样式事件
      updateHeaderStyle();
    }

    // 初始化Fabric画布（适配触屏）
    function initFabricCanvas() {
      const canvasDom = document.getElementById('drawingCanvas');
      pptData.fabricCanvas = new fabric.Canvas('drawingCanvas', {
        isDrawingMode: false,
        preserveObjectStacking: true,
        selection: false,
        width: canvasDom.offsetWidth,
        height: canvasDom.offsetHeight,
        targetFindTolerance: 10,
        perPixelTargetFind: true,
        imageSmoothingEnabled: true
      });

      // 初始化画笔样式
      const brush = new fabric.PencilBrush(pptData.fabricCanvas);
      brush.color = pptData.brushColor;
      brush.width = pptData.brushSize;
      brush.strokeLineCap = 'round';
      brush.strokeLineJoin = 'round';
      brush.decimate = 1;
      pptData.fabricCanvas.freeDrawingBrush = brush;

      // 自适应画布尺寸
      new ResizeObserver(entries => {
        const { width, height } = entries[0].contentRect;
        canvasDom.width = width;
        canvasDom.height = height;
        pptData.fabricCanvas.setWidth(width);
        pptData.fabricCanvas.setHeight(height);
        if (pptData.isFileLoaded) {
          renderCurrentSlideAnnotations();
        }
      }).observe(document.getElementById('slideContainer'));
    }

    // 更新导航栏滚动样式
    function updateHeaderStyle() {
      if (window.scrollY > 10) {
        elements.header.classList.add('py-2', 'shadow');
        elements.header.classList.remove('py-3', 'shadow-sm');
      } else {
        elements.header.classList.add('py-3', 'shadow-sm');
        elements.header.classList.remove('py-2', 'shadow');
      }
    }

    // 显示通知（统一实现）
    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <i class="fa ${type === 'error' ? 'fa-exclamation-circle' : 'fa-check-circle'}"></i>
        <span>${message}</span>
      `;
      elements.notificationContainer.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateY(-20px)';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // 页面加载完成后初始化
window.addEventListener('DOMContentLoaded', init);
    // 处理PPT文件上传（核心解析逻辑）
    function handlePPTUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      // 验证文件类型
      if (!file.name.endsWith('.pptx')) {
        showNotification('请上传.pptx格式的PPT文件', 'error');
        return;
      }

      // 验证文件大小（100MB限制）
      const maxSize = 100 * 1024 * 1024; // 100MB
      if (file.size > maxSize) {
        showNotification('文件大小超过100MB限制，请上传更小文件', 'error');
        elements.fileInput.value = '';
        return;
      }

      // 切换UI到加载状态
      elements.uploadArea.classList.add('hidden');
      elements.pptEditor.classList.add('hidden');
      elements.toolSidebar.classList.add('hidden');
      elements.loadingArea.classList.remove('hidden');
      elements.loadingProgress.textContent = '正在解析文件...';

      // 解析PPT文件（使用pptxjs保留原动画）
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = new Uint8Array(e.target.result);
          pptData.pptRenderer = new PPTX.Presentation();
          pptData.pptRenderer.load(data).then(() => {
            parsePPTWithAnimations();
          }).catch(error => {
            throw new Error(`PPT加载失败：${error.message}`);
          });
        } catch (error) {
          console.error('PPT解析异常:', error);
          showNotification(error.message, 'error');
          // 恢复上传状态
          setTimeout(() => {
            elements.loadingArea.classList.add('hidden');
            elements.uploadArea.classList.remove('hidden');
            elements.fileInput.value = '';
          }, 2000);
        }
      };
      reader.readAsArrayBuffer(file);
    }

    // 解析PPT内容（保留原动画结构）
    function parsePPTWithAnimations() {
      pptData.slides = [];
      pptData.slideAnnotations = [];
      const totalSlides = pptData.pptRenderer.getSlideCount();
      const maxSlides = Math.min(totalSlides, 666); // 限制最大666页

      if (maxSlides === 0) {
        showNotification('PPT文件无有效幻灯片', 'error');
        resetUploadState();
        return;
      }

      // 批量解析幻灯片（控制并发避免卡顿）
      const parsePromises = [];
      for (let i = 0; i < maxSlides; i++) {
        parsePromises.push(
          new Promise(resolve => {
            setTimeout(() => {
              elements.loadingProgress.textContent = `解析第 ${i+1}/${maxSlides} 页（保留动画）`;
              pptData.pptRenderer.getSlide(i).then(slide => {
                // 获取含动画的幻灯片HTML
                const slideHtml = slide.getHTML();
                // 生成缩略图预览
                const thumbnailHtml = `
                  <div class="aspect-[16/9] bg-white border border-gray-200 rounded-md flex items-center justify-center p-2 overflow-hidden">
                    <span class="text-xs text-gray-500 truncate">第 ${i+1} 页${slide.hasAnimations() ? '（含动画）' : ''}</span>
                  </div>
                `;
                // 存储幻灯片数据
                pptData.slides.push({
                  id: `slide-${i}`,
                  html: slideHtml,
                  thumbnail: thumbnailHtml,
                  hasAnimation: slide.hasAnimations()
                });
                // 初始化当前页批注容器
                pptData.slideAnnotations[i] = [];
                resolve();
              }).catch(() => {
                // 单个幻灯片解析失败降级处理
                pptData.slides.push({
                  id: `slide-${i}`,
                  html: `<div class="w-full h-full flex items-center justify-center text-gray-500">第 ${i+1} 页解析失败</div>`,
                  thumbnail: `<div class="aspect-[16/9] bg-white border border-gray-200 rounded-md flex items-center justify-center p-2"><span class="text-xs text-red-500">解析失败</span></div>`,
                  hasAnimation: false
                });
                pptData.slideAnnotations[i] = [];
                resolve();
              });
            }, i * 50); // 错开解析时间，降低性能占用
          })
        );
      }

      // 所有幻灯片解析完成
      Promise.all(parsePromises).then(() => {
        initPPTEditor();
      });
    }

    // 初始化PPT编辑环境（解析完成后调用）
    function initPPTEditor() {
      // 切换UI状态
      elements.loadingArea.classList.add('hidden');
      elements.toolSidebar.classList.remove('hidden');
      elements.pptEditor.classList.remove('hidden');

      // 生成缩略图导航
      renderSlideThumbnails();
      // 显示第一页幻灯片
      showSlide(0);
      // 更新UI状态
      updateSlideCounter();
      updateNavButtonsStatus();
      updateAnimationButtonStatus();
      // 绑定批注工具事件
      bindAnnotationEvents();

      // 启用保存按钮
      pptData.isFileLoaded = true;
      elements.saveFileBtn.disabled = false;
      elements.saveFileBtn.classList.remove('hidden');

      showNotification(`PPT加载成功，共 ${pptData.slides.length} 页（原动画已保留）`);
    }

    // 渲染幻灯片缩略图导航
    function renderSlideThumbnails() {
      elements.thumbnailContainer.innerHTML = '';
      pptData.slides.forEach((slide, index) => {
        const thumbnailEl = document.createElement('div');
        thumbnailEl.className = `thumbnail-item cursor-pointer rounded-md overflow-hidden transition-base ${
          index === 0 ? 'ring-2 ring-primary' : 'hover:ring-2 hover:ring-gray-300'
        }`;
        thumbnailEl.innerHTML = slide.thumbnail;
        thumbnailEl.addEventListener('click', () => showSlide(index));
        elements.thumbnailContainer.appendChild(thumbnailEl);
      });
    }

    // 显示指定索引的幻灯片（含动画初始化）
    function showSlide(index) {
      if (index < 0 || index >= pptData.slides.length) return;

      // 保存当前页批注
      if (pptData.currentSlideIndex >= 0 && pptData.currentSlideIndex < pptData.slideAnnotations.length) {
        pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
      }

      // 更新当前索引
      pptData.currentSlideIndex = index;
      const slide = pptData.slides[index];

      // 渲染幻灯片内容（含原动画）
      elements.slideContent.innerHTML = slide.html;
      // 初始化动画脚本
      initSlideAnimation(index);
      // 渲染批注
      renderCurrentSlideAnnotations();

      // 更新UI状态
      updateThumbnailActiveStatus();
      updateSlideCounter();
      updateNavButtonsStatus();
      updateAnimationButtonStatus();
    }

    // 初始化幻灯片动画（确保原动画可播放）
    function initSlideAnimation(index) {
      const slide = pptData.slides[index];
      if (!slide.hasAnimation) return;

      // 执行幻灯片内置动画脚本（pptxjs生成）
      const slideScripts = elements.slideContent.querySelectorAll('script');
      slideScripts.forEach(script => {
        try {
          const newScript = document.createElement('script');
          newScript.textContent = script.textContent;
          elements.slideContent.appendChild(newScript);
          elements.slideContent.removeChild(newScript);
        } catch (error) {
          console.warn(`第 ${index+1} 页动画初始化失败:`, error);
        }
      });
    }

    // 播放当前幻灯片动画
    function playCurrentSlideAnimation() {
      const slide = pptData.slides[pptData.currentSlideIndex];
      if (!slide.hasAnimation) {
        showNotification('当前幻灯片无动画', 'error');
        return;
      }

      try {
        // 调用pptxjs生成的动画播放函数（格式：slide{索引}_play()）
        const playFunction = window[`slide${pptData.currentSlideIndex}_play`];
        if (typeof playFunction === 'function') {
          playFunction();
          showNotification('动画播放中...');
        } else {
          // 备选方案：触发所有动画元素
          const animationElements = elements.slideContent.querySelectorAll('[data-animation], [style*="animation"]');
          animationElements.forEach(el => {
            el.style.animationPlayState = 'running';
          });
          showNotification('动画播放中...');
        }
      } catch (error) {
        console.error('动画播放失败:', error);
        showNotification('动画播放失败，请重试', 'error');
      }
    }

    // 绑定批注工具相关事件
    function bindAnnotationEvents() {
      // 切换手写模式
      elements.toggleDrawing.addEventListener('click', toggleDrawingMode);
      // 清除当前页批注
      elements.clearAnnotations.addEventListener('click', clearCurrentSlideAnnotations);
      // 调整画笔粗细
      elements.brushSize.addEventListener('input', updateBrushSize);
      // 选择画笔颜色
      elements.colorButtons.forEach(btn => {
        btn.addEventListener('click', (e) => updateBrushColor(e));
      });
      // 幻灯片导航事件
      elements.prevSlide.addEventListener('click', showPrevSlide);
      elements.nextSlide.addEventListener('click', showNextSlide);
      // 动画播放事件
      elements.playAnimationBtn.addEventListener('click', playCurrentSlideAnimation);
      // 保存批注事件
      elements.saveFileBtn.addEventListener('click', saveAnnotations);
    }

    // 切换手写批注模式
    function toggleDrawingMode() {
      pptData.isDrawingMode = !pptData.isDrawingMode;
      pptData.fabricCanvas.isDrawingMode = pptData.isDrawingMode;

      if (pptData.isDrawingMode) {
        // 进入手写模式
        elements.toggleDrawing.classList.remove('bg-primary', 'text-white');
        elements.toggleDrawing.classList.add('bg-red-500', 'text-white');
        elements.toggleDrawing.innerHTML = '<i class="fa fa-stop text-xs mr-1"></i> 退出手写';
        document.getElementById('drawingCanvas').style.cursor = 'crosshair';
        showNotification('已进入手写模式，支持触屏/鼠标绘画');
      } else {
        // 退出手写模式（保存批注）
        pptData.slideAnnotations[pptData.currentSlideIndex] = pptData.fabricCanvas.getObjects();
        elements.toggleDrawing.classList.add('bg-primary', 'text-white');
        elements.toggleDrawing.classList.remove('bg-red-500', 'text-white');
        elements.toggleDrawing.innerHTML = '<i class="fa fa-pencil text-xs mr-1"></i> 手写模式';
        document.getElementById('drawingCanvas').style.cursor = 'default';
        showNotification('已退出手写模式，批注已自动保存');
      }
    }

    // 更新画笔颜色
    function updateBrushColor(e) {
      // 移除所有颜色按钮选中状态
      elements.colorButtons.forEach(btn => btn.classList.remove('border-primary', 'scale-110'));
      // 添加当前选中状态
      e.target.classList.add('border-primary', 'scale-110');
      // 更新画笔颜色
      pptData.brushColor = e.target.dataset.color;
      pptData.fabricCanvas.freeDrawingBrush.color = pptData.brushColor;
      showNotification(`画笔颜色已切换为 ${e.target.dataset.color}`);
    }

    // 更新画笔粗细
    function updateBrushSize(e) {
      pptData.brushSize = parseInt(e.target.value);
      pptData.fabricCanvas.freeDrawingBrush.width = pptData.brushSize;
      showNotification(`画笔粗细已调整为 ${pptData.brushSize}px`);
    }

    // 渲染当前页批注
    function renderCurrentSlideAnnotations() {
      // 清空画布
      pptData.fabricCanvas.clear();
      // 恢复当前页批注
      const currentAnnotations = pptData.slideAnnotations[pptData.currentSlideIndex] || [];
      currentAnnotations.forEach(annotation => {
        pptData.fabricCanvas.add(annotation);
      });
      // 恢复手写模式状态
      pptData.fabricCanvas.isDrawingMode = pptData.isDrawingMode;
    }

    // 清除当前页批注
    function clearCurrentSlideAnnotations() {
      if (!confirm('确定要清除当前页的所有批注吗？此操作不可撤销')) {
        return;
      }
      pptData.slideAnnotations[pptData.currentSlideIndex] = [];
      renderCurrentSlideAnnotations();
      showNotification('当前页批注已清除');
    }

    // 显示上一张幻灯片
    function showPrevSlide() {
      if (pptData.currentSlideIndex > 0) {
        showSlide(pptData.currentSlideIndex - 1);
      }
    }

    // 显示下一张幻灯片
    function showNextSlide() {
      if (pptData.currentSlideIndex < pptData.slides.length - 1) {
        showSlide(pptData.currentSlideIndex + 1);
      }
    }

    // 更新幻灯片计数器
    function updateSlideCounter() {
      elements.slideCounter.textContent = `${pptData.currentSlideIndex + 1} / ${pptData.slides.length}`;
    }

    // 更新导航按钮状态（禁用/启用）
    function updateNavButtonsStatus() {
      elements.prevSlide.disabled = pptData.currentSlideIndex === 0;
      elements.nextSlide.disabled = pptData.currentSlideIndex === pptData.slides.length - 1;
    }

    // 更新动画按钮状态
    function updateAnimationButtonStatus() {
      const hasAnimation = pptData.slides[pptData.currentSlideIndex]?.hasAnimation;
      if (hasAnimation) {
        elements.playAnimationBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        elements.playAnimationBtn.disabled = false;
      } else {
        elements.playAnimationBtn.classList.add('opacity-50', 'cursor-not-allowed');
        elements.playAnimationBtn.disabled = true;
      }
    }

    // 更新缩略图选中状态
    function updateThumbnailActiveStatus() {
      const thumbnails = elements.thumbnailContainer.querySelectorAll('.thumbnail-item');
      thumbnails.forEach((thumb, index) => {
        if (index === pptData.currentSlideIndex) {
          thumb.classList.add('ring-2', 'ring-primary');
          thumb.classList.remove('hover:ring-2', 'hover:ring-gray-300');
          // 滚动到可视区域
          thumb.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
          thumb.classList.remove('ring-2', 'ring-primary');
          thumb.classList.add('hover:ring-2', 'hover:ring-gray-300');
        }
      });
    }

    // 切换全屏模式
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        const container = document.getElementById('slideContainer');
        container.requestFullscreen().catch(() => {
          showNotification('全屏切换失败，请检查浏览器权限', 'error');
        });
      } else {
        document.exitFullscreen();
      }
    }

    // 更新全屏按钮文本
    function updateFullscreenBtn() {
      if (document.fullscreenElement) {
        elements.fullscreenBtn.innerHTML = '<i class="fa fa-compress text-xs mr-1"></i> 退出全屏';
      } else {
        elements.fullscreenBtn.innerHTML = '<i class="fa fa-expand text-xs mr-1"></i> 全屏';
      }
    }

    // 保存批注（生成带批注的图片包）
    function saveAnnotations() {
      elements.saveFileBtn.disabled = true;
      elements.saveFileBtn.innerHTML = '<i class="fa fa-spinner fa-spin text-xs mr-1"></i> 保存中...';

      try {
        const slideImages = [];
        const originalIndex = pptData.currentSlideIndex;
        const total = pptData.slides.length;

        // 批量生成带批注的幻灯片图片
        const generatePromises = pptData.slides.map(async (slide, index) => {
          // 临时切换到当前幻灯片
          showSlide(index);
          // 等待DOM渲染完成
          await new Promise(resolve => setTimeout(resolve, 150));
          // 截图PPT内容+批注
          const canvas = await html2canvas(elements.slideContainer, {
            scale: window.devicePixelRatio || 2,
            useCORS: true,
            backgroundColor: '#ffffff',
            logging: false
          });
          return {
            index: index + 1,
            dataUrl: canvas.toDataURL('image/png'),
            hasAnnotation: pptData.slideAnnotations[index].length > 0
          };
        });

        // 所有图片生成完成
        Promise.all(generatePromises).then(images => {
          // 切换回原始幻灯片
          showSlide(originalIndex);

          // 使用JSZip打包下载
          const zip = new JSZip();
          const date = new Date().toLocaleDateString().replace(/\//g, '-');
          const baseFolder = `PPT批注_${date}`;

          // 创建文件夹
          const annotatedFolder = zip.folder(`${baseFolder}/带批注幻灯片`);
          const originalFolder = zip.folder(`${baseFolder}/原始幻灯片`);

          // 分类添加图片
          images.forEach(img => {
            const base64Data = img.dataUrl.split(',')[1];
            const fileName = `幻灯片${img.index}.png`;
            // 带批注图片
            annotatedFolder.file(fileName, base64Data, { base64: true });
            // 原始图片（重新截图不含批注）
            html2canvas(elements.slideContent, {
              scale: 1,
              useCORS: true,
              backgroundColor: '#ffffff',
              logging: false
            }).then(originalCanvas => {
              const originalBase64 = originalCanvas.toDataURL('image/png').split(',')[1];
              originalFolder.file(fileName, originalBase64, { base64: true });
            });
          });

          // 生成ZIP文件并下载
          zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
          }).then(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseFolder}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            elements.saveFileBtn.disabled = false;
            elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
            showNotification('批注保存成功！已生成含原始+带批注的图片包');
          });
        }).catch(error => {
          throw error;
        });
      } catch (error) {
        console.error('批注保存失败:', error);
        elements.saveFileBtn.disabled = false;
        elements.saveFileBtn.innerHTML = '<i class="fa fa-save text-xs mr-1"></i> 保存批注';
        showNotification('批注保存失败，请重试', 'error');
      }
    }

    // 恢复上传状态（解析失败时调用）
    function resetUploadState() {
      elements.loadingArea.classList.add('hidden');
      elements.uploadArea.classList.remove('hidden');
      elements.fileInput.value = '';
    }
    // Windows11环境检测（用于针对性适配）
    function detectWindows11() {
      const userAgent = navigator.userAgent;
      const isWindows = userAgent.includes('Windows NT');
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Windows 11版本判断（NT 10.0.22000+为Win11）
      const winVersionMatch = userAgent.match(/Windows NT (\d+\.\d+)/);
      const isWin11 = isWindows && winVersionMatch && parseFloat(winVersionMatch[1]) >= 10.0 && 
                      (userAgent.includes('22000') || userAgent.includes('22621') || userAgent.includes('25398'));

      return {
        isWin11,
        isTouchDevice,
        isWin11Touch: isWin11 && isTouchDevice
      };
    }

    // 初始化Windows11适配（在init函数后调用，已整合到核心流程）
    function initWin11Adaptation() {
      const win11Info = detectWindows11();
      if (!win11Info.isWin11) return;

      console.log('检测到Windows11环境，启用专属适配优化');
      showNotification('已启用Windows11专属优化，触屏体验更流畅');

      // 1. UI风格适配Win11（毛玻璃+圆角+阴影优化）
      applyWin11UIStyle();

      // 2. 触屏体验优化（针对Win11触屏设备）
      if (win11Info.isWin11Touch) {
        optimizeWin11TouchExperience();
      }

      // 3. 性能适配（Win11高刷新率/高分屏优化）
      optimizeWin11Performance();

      // 4. 快捷键适配（Win11系统快捷键兼容）
      bindWin11Shortcuts();
    }

    // 应用Windows11 UI风格（毛玻璃效果+圆角优化）
    function applyWin11UIStyle() {
      // 顶部导航栏毛玻璃效果（Win11标志性设计）
      elements.header.classList.add('backdrop-blur-md', 'bg-white/80', 'border-b', 'border-gray-200/50');

      // 卡片组件圆角+阴影优化（Win11更圆润的圆角）
      const cards = document.querySelectorAll('.bg-white.rounded-xl');
      cards.forEach(card => {
        card.classList.remove('rounded-xl');
        card.classList.add('rounded-2xl', 'shadow-md', 'border', 'border-gray-200/30');
      });

      // 按钮样式优化（Win11扁平化+hover效果）
      const buttons = document.querySelectorAll('button:not(.touch-btn)');
      buttons.forEach(btn => {
        btn.classList.add('transition-all', 'duration-200', 'hover:shadow-md');
        // 主按钮额外优化
        if (btn.classList.contains('bg-primary') || btn.classList.contains('bg-green-500')) {
          btn.classList.add('hover:brightness-105', 'active:brightness-95');
        }
      });

      // 输入控件优化（滑块样式Win11化）
      elements.brushSize.classList.add('accent-primary/80');
      elements.brushSize.style.height = '6px';

      // 通知组件优化（Win11通知风格）
      document.querySelectorAll('.notification').forEach(notify => {
        notify.classList.add('rounded-lg', 'shadow-lg', 'backdrop-blur-sm');
      });
    }

    // Windows11触屏体验优化（核心适配点）
    function optimizeWin11TouchExperience() {
      // 1. 增大触屏点击区域（Win11触屏目标尺寸≥44px）
      const touchTargets = document.querySelectorAll('.thumbnail-item, [data-color], .touch-btn');
      touchTargets.forEach(target => {
        target.classList.add('min-w-[44px]', 'min-h-[44px]', 'p-1');
      });

      // 2. 手写模式触屏优化（降低延迟+提升笔触流畅度）
      pptData.fabricCanvas.freeDrawingCursor = 'none'; // 隐藏光标，提升沉浸感
      pptData.fabricCanvas.setWidth(pptData.fabricCanvas.width * window.devicePixelRatio);
      pptData.fabricCanvas.setHeight(pptData.fabricCanvas.height * window.devicePixelRatio);
      pptData.fabricCanvas.setZoom(1 / window.devicePixelRatio); // 高分屏触屏精准度优化

      // 3. 触屏手势支持（Win11常见手势：滑动切换幻灯片）
      let touchStartX = 0;
      const slideContainer = document.getElementById('slideContainer');
      
      slideContainer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
        }
      }, { passive: true });

      slideContainer.addEventListener('touchend', (e) => {
        if (e.changedTouches.length === 1) {
          const touchEndX = e.changedTouches[0].clientX;
          const deltaX = touchEndX - touchStartX;

          // 左右滑动切换幻灯片（阈值100px，避免误触）
          if (Math.abs(deltaX) > 100) {
            if (deltaX < 0 && pptData.currentSlideIndex < pptData.slides.length - 1) {
              showNextSlide(); // 左滑→下一页
            } else if (deltaX > 0 && pptData.currentSlideIndex > 0) {
              showPrevSlide(); // 右滑→上一页
            }
          }
        }
      }, { passive: true });

      // 4. 触屏长按事件优化（避免Win11系统长按菜单干扰）
      slideContainer.addEventListener('contextmenu', (e) => {
        if (pptData.isDrawingMode) {
          e.preventDefault(); // 手写模式禁用系统右键菜单
        }
      });

      // 5. 批注工具触屏反馈（震动+视觉反馈）
      elements.toggleDrawing.addEventListener('touchstart', () => {
        if (navigator.vibrate) navigator.vibrate(50); // 轻微震动反馈
      }, { passive: true });

      elements.colorButtons.forEach(btn => {
        btn.addEventListener('touchstart', () => {
          if (navigator.vibrate) navigator.vibrate(30);
        }, { passive: true });
      });
    }

    // Windows11性能优化（高刷新率/高分屏/资源调度）
    function optimizeWin11Performance() {
      // 1. 高刷新率适配（Win11常见120Hz/144Hz屏幕，降低动画卡顿）
      if (window.matchMedia('(prefers-reduced-motion: no-preference)').matches) {
        document.documentElement.style.setProperty('--animation-duration', '0.2s');
        document.querySelectorAll('.transition-base').forEach(el => {
          el.classList.add('duration-150');
        });
      }

      // 2. 高分屏（4K/2K）适配（避免模糊）
      const dpr = window.devicePixelRatio || 1;
      if (dpr > 1.5) {
        // 调整画布缩放，提升批注清晰度
        const canvasDom = document.getElementById('drawingCanvas');
        const originalWidth = canvasDom.width;
        const originalHeight = canvasDom.height;
        
        canvasDom.width = originalWidth * dpr;
        canvasDom.height = originalHeight * dpr;
        canvasDom.style.width = `${originalWidth}px`;
        canvasDom.style.height = `${originalHeight}px`;
        
        pptData.fabricCanvas.setWidth(originalWidth * dpr);
        pptData.fabricCanvas.setHeight(originalHeight * dpr);
        pptData.fabricCanvas.setZoom(1 / dpr);
      }

      // 3. Win11后台资源调度优化（避免休眠时卡顿）
      if (navigator.wakeLock) {
        let wakeLock = null;
        // 手写模式时保持屏幕常亮+资源活跃
        elements.toggleDrawing.addEventListener('click', async () => {
          if (pptData.isDrawingMode && !wakeLock) {
            try {
              wakeLock = await navigator.wakeLock.request('screen');
            } catch (error) {
              console.warn('Win11屏幕常亮请求失败:', error);
            }
          } else if (wakeLock) {
            wakeLock.release();
            wakeLock = null;
          }
        });
      }

      // 4. 幻灯片切换性能优化（Win11预加载机制）
      pptData.slides.forEach((slide, index) => {
        // 预加载相邻2页幻灯片HTML，提升切换速度
        if (Math.abs(index - pptData.currentSlideIndex) <= 2) {
          const tempDiv = document.createElement('div');
          tempDiv.style.display = 'none';
          tempDiv.innerHTML = slide.html;
          document.body.appendChild(tempDiv);
          setTimeout(() => document.body.removeChild(tempDiv), 3000);
        }
      });
    }

    // Windows11快捷键适配（兼容系统快捷键，新增专属操作）
    function bindWin11Shortcuts() {
      document.addEventListener('keydown', (e) => {
        // Win11系统快捷键兼容：避免与系统冲突
        if (e.metaKey && (e.key === 'd' || e.key === 'm' || e.key === 'tab')) {
          return; // 保留Win+D/Win+M/Win+Tab等系统快捷键
        }

        // 自定义快捷键（适配Win11操作习惯）
        switch (e.key.toLowerCase()) {
          // 左右箭头切换幻灯片（Win11常见导航逻辑）
          case 'arrowleft':
            if (!e.ctrlKey && !e.shiftKey) {
              showPrevSlide();
              e.preventDefault();
            }
            break;
          case 'arrowright':
            if (!e.ctrlKey && !e.shiftKey) {
              showNextSlide();
              e.preventDefault();
            }
            break;
          // Ctrl+S快速保存批注（Win11保存习惯）
          case 's':
            if (e.ctrlKey && pptData.isFileLoaded) {
              saveAnnotations();
              e.preventDefault();
            }
            break;
          // Ctrl+Z撤销批注（Win11编辑习惯）
          case 'z':
            if (e.ctrlKey && !e.shiftKey && pptData.fabricCanvas.canUndo()) {
              pptData.fabricCanvas.undo();
              e.preventDefault();
              showNotification('已撤销上一步批注');
            }
            break;
          // Ctrl+Shift+Z重做批注
          case 'z':
            if (e.ctrlKey && e.shiftKey && pptData.fabricCanvas.canRedo()) {
              pptData.fabricCanvas.redo();
              e.preventDefault();
              showNotification('已重做批注');
            }
            break;
          // F5播放动画（Win11PPT默认播放快捷键）
          case 'f5':
            playCurrentSlideAnimation();
            e.preventDefault();
            break;
        }
      });
    }

    // 扩展Fabric画布撤销/重做功能（Win11编辑体验必备）
    (function extendFabricUndoRedo() {
      const fabricCanvas = pptData.fabricCanvas;
      if (!fabricCanvas) return;

      // 初始化撤销栈和重做栈
      fabricCanvas.undoStack = [];
      fabricCanvas.redoStack = [];
      fabricCanvas.isRecording = false;

      // 重写添加对象方法，记录撤销状态
      const originalAdd = fabricCanvas.add;
      fabricCanvas.add = function(...objects) {
        if (!this.isRecording) {
          this.recordState();
        }
        return originalAdd.apply(this, objects);
      };

      // 重写移除对象方法，记录撤销状态
      const originalRemove = fabricCanvas.remove;
      fabricCanvas.remove = function(...objects) {
        if (!this.isRecording) {
          this.recordState();
        }
        return originalRemove.apply(this, objects);
      };

      // 记录当前状态到撤销栈
      fabricCanvas.recordState = function() {
        this.undoStack.push(this.toJSON(['left', 'top', 'width', 'height', 'fill', 'stroke', 'strokeWidth', 'type']));
        this.redoStack = []; // 新增操作清空重做栈
        // 限制撤销栈大小（最多50步，避免内存占用）
        if (this.undoStack.length > 50) {
          this.undoStack.shift();
        }
      };

      // 撤销操作
      fabricCanvas.undo = function() {
        if (!this.canUndo()) return false;
        this.isRecording = true;
        this.redoStack.push(this.toJSON());
        const prevState = this.undoStack.pop();
        this.loadFromJSON(prevState, () => {
          this.renderAll();
          this.isRecording = false;
        });
        return true;
      };

      // 重做操作
      fabricCanvas.redo = function() {
        if (!this.canRedo()) return false;
        this.isRecording = true;
        this.undoStack.push(this.toJSON());
        const nextState = this.redoStack.pop();
        this.loadFromJSON(nextState, () => {
          this.renderAll();
          this.isRecording = false;
        });
        return true;
      };

      // 检查是否可撤销
      fabricCanvas.canUndo = function() {
        return this.undoStack.length > 0;
      };

      // 检查是否可重做
      fabricCanvas.canRedo = function() {
        return this.redoStack.length > 0;
      };
    })();

    // 在核心初始化流程中添加Win11适配（确保加载完成后执行）
    window.addEventListener('DOMContentLoaded', () => {
      // 原初始化逻辑执行后，延迟启动Win11适配（确保DOM和核心功能就绪）
      setTimeout(initWin11Adaptation, 500);
    });

    // 修复Win11下pptxjs动画兼容性问题（部分动画不触发）
    function fixWin11PPTAnimation() {
      const win11Info = detectWindows11();
      if (!win11Info.isWin11) return;

      // 重写pptxjs动画触发逻辑（Win11下使用requestAnimationFrame提升兼容性）
      if (window.PPTX && window.PPTX.Slide.prototype.hasOwnProperty('getHTML')) {
        const originalGetHTML = PPTX.Slide.prototype.getHTML;
        PPTX.Slide.prototype.getHTML = function() {
          let html = originalGetHTML.apply(this, arguments);
          // 替换动画脚本中的setTimeout为requestAnimationFrame（Win11更稳定）
          html = html.replace(/setTimeout\(([^,]+),\s*(\d+)\)/g, (match, func, time) => {
            return `requestAnimationFrame(() => setTimeout(${func}, ${time}))`;
          });
          return html;
        };
      }
    }

    // 提前执行动画兼容性修复（在PPT解析前生效）
    fixWin11PPTAnimation();
    // 一、功能完善：新增实用特性（提升整体体验）
    // 1. 批注样式扩展（支持虚线/实线切换，Win11办公场景常用）
    function extendAnnotationStyles() {
      // 添加样式切换按钮到工具栏
      const styleGroup = document.createElement('div');
      styleGroup.className = 'flex space-x-2 mt-2';
      styleGroup.innerHTML = `
        <button id="solidLine" class="flex-1 bg-primary text-white px-2 py-2 rounded-md text-sm transition-base touch-optimized">
          <i class="fa fa-minus text-xs mr-1"></i> 实线
        </button>
        <button id="dashedLine" class="flex-1 bg-gray-100 text-gray-700 px-2 py-2 rounded-md text-sm transition-base touch-optimized">
          <i class="fa fa-minus text-xs mr-1" style="letter-spacing: 2px;"></i> 虚线
        </button>
      `;
      elements.toolSidebar.querySelector('.space-y-3').appendChild(styleGroup);

      // 绑定样式切换事件
      document.getElementById('solidLine').addEventListener('click', () => {
        pptData.fabricCanvas.freeDrawingBrush.strokeDashArray = [];
        document.getElementById('solidLine').classList.add('bg-primary', 'text-white');
        document.getElementById('solidLine').classList.remove('bg-gray-100', 'text-gray-700');
        document.getElementById('dashedLine').classList.add('bg-gray-100', 'text-gray-700');
        document.getElementById('dashedLine').classList.remove('bg-primary', 'text-white');
        showNotification('批注样式已切换为实线');
      });

      document.getElementById('dashedLine').addEventListener('click', () => {
        pptData.fabricCanvas.freeDrawingBrush.strokeDashArray = [5, 5];
        document.getElementById('dashedLine').classList.add('bg-primary', 'text-white');
        document.getElementById('dashedLine').classList.remove('bg-gray-100', 'text-gray-700');
        document.getElementById('solidLine').classList.add('bg-gray-100', 'text-gray-700');
        document.getElementById('solidLine').classList.remove('bg-primary', 'text-white');
        showNotification('批注样式已切换为虚线');
      });

      // 初始化默认样式（实线）
      pptData.fabricCanvas.freeDrawingBrush.strokeDashArray = [];
    }

    // 2. 单页导出功能（除了批量打包，支持单独导出当前页）
    function addSinglePageExport() {
      const exportBtn = document.createElement('button');
      exportBtn.id = 'exportCurrentPage';
      exportBtn.className = 'mt-3 w-full bg-blue-500 hover:bg-blue-600 text-white px-2 py-2 rounded-md text-sm transition-base touch-optimized';
      exportBtn.innerHTML = '<i class="fa fa-download text-xs mr-1"></i> 导出当前页（带批注）';
      elements.toolSidebar.querySelector('.space-y-3').appendChild(exportBtn);

      exportBtn.addEventListener('click', async () => {
        exportBtn.disabled = true;
        exportBtn.innerHTML = '<i class="fa fa-spinner fa-spin text-xs mr-1"></i> 导出中...';

        try {
          // 截图当前页（含批注）
          const canvas = await html2canvas(elements.slideContainer, {
            scale: window.devicePixelRatio || 2,
            useCORS: true,
            backgroundColor: '#ffffff',
            logging: false
          });

          // 生成下载链接
          const url = canvas.toDataURL('image/png');
          const a = document.createElement('a');
          a.href = url;
          a.download = `幻灯片${pptData.currentSlideIndex + 1}_带批注.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          exportBtn.disabled = false;
          exportBtn.innerHTML = '<i class="fa fa-download text-xs mr-1"></i> 导出当前页（带批注）';
          showNotification('当前页导出成功！');
        } catch (error) {
          console.error('单页导出失败:', error);
          exportBtn.disabled = false;
          exportBtn.innerHTML = '<i class="fa fa-download text-xs mr-1"></i> 导出当前页（带批注）';
          showNotification('单页导出失败，请重试', 'error');
        }
      });
    }

    // 3. 批注透明度调节（Win11专业办公场景需求）
    function addAnnotationOpacityControl() {
      const opacityGroup = document.createElement('div');
      opacityGroup.className = 'mt-3';
      opacityGroup.innerHTML = `
        <label class="block text-xs text-gray-500 mb-1.5">批注透明度</label>
        <input type="range" id="annotationOpacity" min="30" max="100" value="100" class="w-full accent-primary">
        <div class="flex justify-between text-xs text-gray-400 mt-1">
          <span>透明</span>
          <span>不透明</span>
        </div>
      `;
      elements.toolSidebar.querySelector('.space-y-3').appendChild(opacityGroup);

      const opacitySlider = document.getElementById('annotationOpacity');
      opacitySlider.addEventListener('input', (e) => {
        const opacity = parseInt(e.target.value) / 100;
        pptData.fabricCanvas.freeDrawingBrush.opacity = opacity;
        // 同步更新已有批注透明度
        pptData.fabricCanvas.getObjects().forEach(obj => {
          obj.set('opacity', opacity);
        });
        pptData.fabricCanvas.renderAll();
        showNotification(`批注透明度已调整为 ${e.target.value}%`);
      });

      // 初始化透明度（100%不透明）
      pptData.fabricCanvas.freeDrawingBrush.opacity = 1;
    }

    // 二、错误处理强化（全流程容错，避免程序崩溃）
    // 1. 全局错误捕获（防止未知错误导致页面卡死）
    function initGlobalErrorHandler() {
      // 捕获JS执行错误
      window.addEventListener('error', (e) => {
        console.error('全局错误:', e.message, e.filename, e.lineno);
        showNotification('程序出现未知错误，已自动恢复', 'error');
        // 紧急恢复措施：退出手写模式+清空画布
        if (pptData.isDrawingMode) {
          toggleDrawingMode();
        }
        if (pptData.fabricCanvas) {
          pptData.fabricCanvas.clear();
        }
      });

      // 捕获Promise未处理错误
      window.addEventListener('unhandledrejection', (e) => {
        console.error('未处理Promise错误:', e.reason);
        showNotification('操作执行失败，请重试', 'error');
        e.preventDefault();
      });
    }

    // 2. 画布异常恢复（Win11下偶发画布渲染失败）
    function initCanvasRecovery() {
      setInterval(() => {
        if (pptData.fabricCanvas && !pptData.fabricCanvas.isRenderingCorrectly) {
          try {
            pptData.fabricCanvas.renderAll();
            pptData.fabricCanvas.isRenderingCorrectly = true;
          } catch (error) {
            console.warn('画布渲染异常，尝试恢复:', error);
            renderCurrentSlideAnnotations();
          }
        }
      }, 5000); // 每5秒检查一次
    }

    // 3. 网络错误处理（依赖CDN加载失败降级）
    function initCdnFallback() {
      // 检查核心CDN资源是否加载成功
      const checkCdnResource = (url, name) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = img.onerror = () => {
            resolve(!!img.complete);
          };
          img.src = url;
        });
      };

      // 检查html2canvas CDN（截图核心依赖）
      checkCdnResource('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js', 'html2canvas')
        .then(isLoaded => {
          if (!isLoaded) {
            console.warn('html2canvas CDN加载失败，使用降级方案');
            // 降级为纯批注数据导出（无图片截图）
            elements.saveFileBtn.addEventListener('click', () => {
              const annotationData = JSON.stringify({
                slidesCount: pptData.slides.length,
                annotations: pptData.slideAnnotations,
                exportTime: new Date().toLocaleString()
              });
              const blob = new Blob([annotationData], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `PPT批注数据_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              showNotification('批注数据导出成功（CDN加载失败，仅导出批注坐标数据）');
            });
          }
        });
    }

    // 三、程序初始化完善（整合所有功能）
    function completeInit() {
      // 扩展批注功能
      extendAnnotationStyles();
      addSinglePageExport();
      addAnnotationOpacityControl();

      // 强化错误处理
      initGlobalErrorHandler();
      initCanvasRecovery();
      initCdnFallback();

      // 显示初始化完成通知
      showNotification('所有功能已就绪，支持Win11触屏+快捷键操作');
    }

    // 四、启动完整初始化流程（确保所有依赖加载完成）
    window.addEventListener('DOMContentLoaded', () => {
      // 延迟执行完整初始化（等待核心功能就绪）
      setTimeout(completeInit, 1000);
    });

    // 五、程序闭合（确保所有函数声明完成，无语法错误）
    // 验证核心函数是否存在（避免初始化顺序问题）
    window.addEventListener('load', () => {
      const requiredFunctions = [
        'init', 'handlePPTUpload', 'showSlide', 'toggleDrawingMode',
        'saveAnnotations', 'initWin11Adaptation', 'completeInit'
      ];
      const missingFunctions = requiredFunctions.filter(fn => typeof window[fn] !== 'function');
      
      if (missingFunctions.length > 0) {
        console.error('核心函数缺失:', missingFunctions);
        showNotification('程序初始化不完整，部分功能可能无法使用', 'error');
      } else {
        console.log('PPT批注工具初始化完成（支持Windows11全适配）');
      }
    });
  </script>
</body>
</html>
